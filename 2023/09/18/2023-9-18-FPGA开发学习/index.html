<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>FPGA开发学习 | Spencer</title><meta name="author" content="Spencer"><meta name="copyright" content="Spencer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="9-18 勿忘国耻！ 先来补充一下我读了一个博主写的如何用硬件思维去写c++，并且适应HLS(High-Level synthesis)的规则。 我就被HLS的功能所误导，以前以为只要写出了c&amp;#x2F;c++，就可以通过HLS进行硬件电路转换得到RTL硬件电路，但是c&amp;#x2F;c++代码能否转换成满足实际工程需求（"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.mathming.ltd/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-NFDHX1L800"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-NFDHX1L800');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":10,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Spencer","link":"Link: ","source":"Source: Spencer","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FPGA开发学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-21 19:29:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">166</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">37</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-gallery"></i><span> Gallery</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images.pexels.com/photos/1903702/pexels-photo-1903702.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Spencer</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-gallery"></i><span> Gallery</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">FPGA开发学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-09-17T16:00:00.000Z" title="Created 2023-09-18 00:00:00">2023-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-10-21T11:29:11.499Z" title="Updated 2023-10-21 19:29:11">2023-10-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/FPGA/">FPGA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="FPGA开发学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>9-18 勿忘国耻！</strong></p>
<p>先来补充一下我读了一个博主写的如何用硬件思维去写c++，并且适应HLS(High-Level synthesis)的规则。</p>
<p>我就被HLS的功能所误导，以前以为只要写出了c/c++，就可以通过HLS进行硬件电路转换得到RTL硬件电路，但是c/c++代码能否转换成满足实际工程需求（面积，速度）的RTL代码是个问题，也就是，转换期间，是存在代沟的。从语言特征的角度来看，c/c++与verilog有着本质的区别。</p>
<p>c++是顺序执行的，而HDL(Hardware Description Language)是并行执行的。因为HDL描述的是硬件电路，一旦上电，所有电路单元并行工作，HDL的并行特征正体现了硬件电路的这个特点。</p>
<p>c++是静态的，HDL是动态的。静态就是我们用c++时只需要关注算法本身，而使用HDL描述算法时，我们要关注的是如何将算法映射为硬件电路，关注每个时钟周期电路应该实现的行为。电路在时钟下工作，数据随时钟流动，时钟也就是时间的基本单位，或者说执行一次运算的基本时间单位。</p>
<p>c++是没有时序性的，而时序性是HDL的一个显著特征，比如时序逻辑电路。所以我们不能只考虑c++中算法的描述，还要考虑用流水线的方式使得数据在各个处理单元之间流动，同时设计者还要管理好每个处理单元完成操作所需要的时钟周期。也就是要考虑关键路径（最长路径）的门延迟。</p>
<p>但是c++和HDL也有相似之处，比如c++是顺序执行，而在有限状态机里面HDL也是顺序执行。比如c++的for循环，就可以翻译成有限状态机里面的进入不同状态执行不同逻辑体。我们知道执行循环非常耗时，用HDL描述状态机时我们回忆，需要考虑状态转移条件，每个状态持续的时钟周期个数。在for循环中，进入/退出for循环各需要一个时钟周期，每次for循环所需要的是时钟周期个数就取决于循环体内的操作。<strong>整个循环所需要的时钟周期时和循环次数相关的，所以说我们尽可能要让循环最大次数是常数</strong></p>
<p>c++最常用的数据类型是数组，所以是占用存储空间的。而FPGA中记忆元件包括寄存器和RAM，数组最终都可以被映射到这两类元件中。在HDL中描述RAM时，我们要给出RAM的宽度和深度，从而使得工具可以在FPGA中分配固定的存储单元。</p>
<p>尽管c++中支持动态数组，但是HLS时确不支持，所以HLS要求c++中的数组必须为固定大小，和HDL要求一致。</p>
<p>Vitis HLS将c++转换为RTL代码时分为三大过程：进度安排（scheduling），绑定(binding)和状态提取。Scheduling解决的是什么时候做什么事，进一步而言就是时钟周期需要执行的操作。binding解决的是绑定需要的硬件资源，状态提取就是字面含义了，就是在c++代码中提取有限状态机。</p>
<h2 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h2><p>Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( <span class="keyword">output</span> one );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert your code here</span></span><br><span class="line">    <span class="keyword">assign</span> one = <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="Zero"><a href="#Zero" class="headerlink" title="Zero"></a>Zero</h3><p>Build a circuit with no inputs and one output that outputs a constant <code>0</code></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">output</span> zero</span><br><span class="line">);<span class="comment">// Module body starts after semicolon</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="verilog-Language"><a href="#verilog-Language" class="headerlink" title="verilog Language"></a>verilog Language</h2><h3 id="simple-wire"><a href="#simple-wire" class="headerlink" title="simple wire"></a>simple wire</h3><p>Create a module with one input and one output that behaves like a wire.</p>
<p>Unlike physical wires, wires (and other signals) in Verilog are <em>directional</em>. This means information flows in only one direction, from (usually one) <em>source</em> to the <em>sinks</em> (The source is also often called a <em>driver</em> that <em>drives</em> a value onto a wire). In a Verilog “continuous assignment” (<code>assign left_side = right_side;</code>), the value of the signal on the right side is driven onto the wire on the left side. The assignment is “continuous” because the assignment continues all the time even if the right side’s value changes. A continuous assignment is not a one-time event.</p>
<p>The ports on a module also have a direction (usually input or output). An input port is <em>driven by</em> something from outside the module, while an output port <em>drives</em> something outside. When viewed from inside the module, an input port is a driver or source, while an output port is a sink.</p>
<p>The diagram below illustrates how each part of the circuit corresponds to each bit of Verilog code. The module and port declarations create the black portions of the circuit. Your task is to create a wire (in green) by adding an <code>assign</code> statement to connect <code>in</code> to <code>out</code>. The parts outside the box are not your concern, but you should know that your circuit is tested by connecting signals from our test harness to the ports on your <code>top_module</code>.</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Wire.png" alt="Wire.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( <span class="keyword">input</span> in, <span class="keyword">output</span> out );</span><br><span class="line">    <span class="keyword">assign</span> out = in;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="wire-4"><a href="#wire-4" class="headerlink" title="wire 4"></a>wire 4</h3><p>Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; w</span><br><span class="line">b -&gt; x</span><br><span class="line">b -&gt; y</span><br><span class="line">c -&gt; z</span><br></pre></td></tr></table></figure>
<p>The diagram below illustrates how each part of the circuit corresponds to each bit of Verilog code. From outside the module, there are three input ports and four output ports.</p>
<p>When you have multiple <code>assign</code> statements, the <strong>order</strong> in which they appear in the code <strong>does not matter</strong>. Unlike a programming language, <code>assign</code> statements (“continuous assignments”) describe <em>connections</em> between things, not the <em>action</em> of copying a value from one thing to another.</p>
<p>One potential source of confusion that should perhaps be clarified now: The green arrows here represent connections <em>between</em> wires, but are not wires in themselves. The module itself <em>already</em> has 7 wires declared (named a, b, c, w, x, y, and z). This is because <code>input</code> and <code>output</code> declarations actually declare a wire unless otherwise specified. Writing <code>input wire a</code> is the same as <code>input a</code>. Thus, the <code>assign</code> statements are not creating wires, they are creating the connections between the 7 wires that already exist.</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Wire4.png" alt="Wire4.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> a,b,c,</span><br><span class="line">    <span class="keyword">output</span> w,x,y,z );</span><br><span class="line">    <span class="keyword">assign</span> w = a;</span><br><span class="line">    <span class="keyword">assign</span> x = b;</span><br><span class="line">    <span class="keyword">assign</span> y = b;</span><br><span class="line">    <span class="keyword">assign</span> z = c;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="Not-gate"><a href="#Not-gate" class="headerlink" title="Not gate"></a>Not gate</h3><p>Create a module that implements a NOT gate.</p>
<p>This circuit is similar to <a target="_blank" rel="noopener" href="https://hdlbits.01xz.net/wiki/wire">wire</a>, but with a slight difference. When making the connection from the wire <code>in</code> to the wire <code>out</code> we’re going to implement an inverter (or “NOT-gate”) instead of a plain wire.</p>
<p>Use an assign statement. The <code>assign</code> statement will <em>continuously drive</em> the inverse of <code>in</code> onto wire <code>out</code>.</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Notgate.png" alt="Notgate.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( <span class="keyword">input</span> in, <span class="keyword">output</span> out );</span><br><span class="line">    <span class="keyword">assign</span> out = ~in;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="Andgate"><a href="#Andgate" class="headerlink" title="Andgate"></a>Andgate</h3><p>Create a module that implements an AND gate.</p>
<p>This circuit now has three wires (<code>a</code>, <code>b</code>, and <code>out</code>). Wires <code>a</code> and <code>b</code> already have values driven onto them by the input ports. But wire <code>out</code> currently is not driven by anything. Write an <code>assign</code> statement that drives <code>out</code> with the AND of signals <code>a</code> and <code>b</code>.</p>
<p>Note that this circuit is very similar to the <a target="_blank" rel="noopener" href="https://hdlbits.01xz.net/wiki/notgate">NOT gate</a>, just with one more input. If it sounds different, it’s because I’ve started describing signals as being <em>driven</em> (has a known value determined by something attached to it) or <em>not driven</em> by something. <code>Input wires</code> are driven by something outside the module. <code>assign</code> statements will drive a logic level onto a wire. As you might expect, a wire cannot have more than one driver (what is its logic level if there is?), and a wire that has no drivers will have an undefined value (often treated as 0 when synthesizing hardware).</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Andgate.png" alt="Andgate.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b, </span><br><span class="line">    <span class="keyword">output</span> out );</span><br><span class="line">    <span class="keyword">assign</span> out = a&amp;b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="Norgate"><a href="#Norgate" class="headerlink" title="Norgate"></a>Norgate</h3><p>Create a module that implements a NOR gate. A NOR gate is an OR gate with its output inverted. A NOR function needs two operators when written in Verilog.</p>
<p>An <code>assign</code> statement drives a wire (or “net”, as it’s more formally called) with a value. This value can be as complex a function as you want, as long as it’s a <em>combinational</em> (i.e., memory-less, with no hidden state) function. An <code>assign</code> statement is a <em>continuous assignment</em> because the output is “recomputed” whenever any of its inputs change, forever, much like a simple logic gate.</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Norgate.png" alt="Norgate.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b, </span><br><span class="line">    <span class="keyword">output</span> out );</span><br><span class="line">    <span class="keyword">assign</span> out = ~(a || b);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="Xnorgate"><a href="#Xnorgate" class="headerlink" title="Xnorgate"></a>Xnorgate</h3><p>Create a module that implements an XNOR gate.</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Xnorgate.png" alt="Xnorgate.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b, </span><br><span class="line">    <span class="keyword">output</span> out );</span><br><span class="line">    <span class="keyword">assign</span> out = ~(a^b);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Declaring-wires"><a href="#Declaring-wires" class="headerlink" title="Declaring wires"></a>Declaring wires</h2><p>The circuits so far have been simple enough that the outputs are simple functions of the inputs. As circuits become more complex, you will need wires to connect internal components together. When you need to use a wire, you should declare it in the body of the module, somewhere before it is first used. (In the future, you will encounter more types of signals and variables that are also declared the same way, but for now, we’ll start with a signal of type <code>wire</code>).</p>
<p><strong>Example:</strong></p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Wiredecl1.png" alt="Wiredecl1.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> in,              <span class="comment">// Declare an input wire named &quot;in&quot;</span></span><br><span class="line">    <span class="keyword">output</span> out             <span class="comment">// Declare an output wire named &quot;out&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> not_in;           <span class="comment">// Declare a wire named &quot;not_in&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> out = ~not_in;  <span class="comment">// Assign a value to out (create a NOT gate).</span></span><br><span class="line">    <span class="keyword">assign</span> not_in = ~in;   <span class="comment">// Assign a value to not_in (create another NOT gate).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span>   <span class="comment">// End of module &quot;top_module&quot;</span></span><br></pre></td></tr></table></figure>
<p>two NOT gates are created using two <code>assign</code> statements.Note that it doesn’t matter which of the NOT gates you create first: You still end up with the same circuit.定义顺序没关系！先定义哪个都行！</p>
<p><strong>practice</strong></p>
<p>Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire <code>out</code>, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.</p>
<p>If you’re following the circuit structure in the diagram, you should end up with four assign statements, as there are four signals that need a value assigned.</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Wiredecl2.png" alt="Wiredecl2.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">default_nettype</span> none</span></span><br><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">input</span> c,</span><br><span class="line">    <span class="keyword">input</span> d,</span><br><span class="line">    <span class="keyword">output</span> out,</span><br><span class="line">    <span class="keyword">output</span> out_n   ); </span><br><span class="line">    <span class="keyword">wire</span> one_one;</span><br><span class="line">    <span class="keyword">wire</span> one_two;<span class="comment">//左边的两条</span></span><br><span class="line">    <span class="keyword">wire</span> two;<span class="comment">//右边的一条</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> one_one = a&amp;b;</span><br><span class="line">    <span class="keyword">assign</span> one_two = c&amp;d;</span><br><span class="line">    <span class="keyword">assign</span> two = one_one || one_two;</span><br><span class="line">    <span class="keyword">assign</span> out = two;</span><br><span class="line">    <span class="keyword">assign</span> out_n = ~two;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="7458-chip"><a href="#7458-chip" class="headerlink" title="7458 chip"></a>7458 chip</h2><p>The 7458 is a chip with four AND gates and two OR gates. This problem is slightly more complex than <a target="_blank" rel="noopener" href="https://hdlbits.01xz.net/wiki/7420">7420</a>.</p>
<p>Create a module with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an <code>assign</code> statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates. For extra practice, try it both ways.</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/7458.png" alt="7458.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module ( </span><br><span class="line">    <span class="keyword">input</span> p1a, p1b, p1c, p1d, p1e, p1f,</span><br><span class="line">    <span class="keyword">output</span> p1y,</span><br><span class="line">    <span class="keyword">input</span> p2a, p2b, p2c, p2d,</span><br><span class="line">    <span class="keyword">output</span> p2y );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wire</span> a2_b2;<span class="comment">//p2a和p2b生成的线</span></span><br><span class="line">    <span class="keyword">wire</span> c2_d2;</span><br><span class="line">    <span class="keyword">wire</span> c1_b1_a1;</span><br><span class="line">    <span class="keyword">wire</span> d1_e1_f1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> a2_b2 = p2a &amp; p2b;</span><br><span class="line">    <span class="keyword">assign</span> c2_d2 = p2c &amp; p2d;</span><br><span class="line">    <span class="keyword">assign</span> c1_b1_a1 = p1a &amp; p1b &amp; p1c;</span><br><span class="line">    <span class="keyword">assign</span> d1_e1_f1 = p1d &amp; p1e &amp; p1f;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> p1y= c1_b1_a1 || d1_e1_f1;</span><br><span class="line">    <span class="keyword">assign</span> p2y = a2_b2 &amp; c2_d2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Vector0-其实就是数组，将多个线合并成一个数组"><a href="#Vector0-其实就是数组，将多个线合并成一个数组" class="headerlink" title="Vector0(其实就是数组，将多个线合并成一个数组)"></a>Vector0(其实就是数组，将多个线合并成一个数组)</h2><p>向量被用来将相关信号归类，使其更容易被操作。比如<code>wire [7:0] w;</code> 声明了一个8位的向量w，在功能上等价于有8条分开的线。</p>
<p>Notice that the <em>declaration</em> of a vector places the dimensions <em>before</em> the name of the vector, which is unusual compared to C syntax. However, the <em>part select</em> has the dimensions <em>after</em> the vector name as you would expect.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wire **[99:0]** my_vector;      // Declare a 100-element vector assign out = my_vector**[10]**; // Part-select one bit out of the vector </span><br></pre></td></tr></table></figure>
<p>Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output <code>o0</code> to the input vector’s position 0, <code>o1</code> to position 1, etc.</p>
<p>In a diagram, a tick mark with a number next to it indicates the width of the vector (or “bus”), rather than drawing a separate line for each bit in the vector.</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Vector0.png" alt="Vector0.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module ( </span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] vec,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] outv,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> o2,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> o1,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> o0  ); <span class="comment">// Module body starts after module declaration</span></span><br><span class="line">    <span class="keyword">assign</span> outv[<span class="number">0</span>] = o0;</span><br><span class="line">    <span class="keyword">assign</span> outv[<span class="number">1</span>] = o1;</span><br><span class="line">    <span class="keyword">assign</span> outv[<span class="number">2</span>] = o2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> o0 = vec[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> o1 = vec[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> o2 = vec[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Vector1"><a href="#Vector1" class="headerlink" title="Vector1"></a>Vector1</h2><h3 id="Declaring-Vectors"><a href="#Declaring-Vectors" class="headerlink" title="Declaring Vectors"></a>Declaring Vectors</h3><p>Vectors must be declared:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type [upper:lower] vector_name;</span><br></pre></td></tr></table></figure>
<p><code>type</code> 指定了向量的数据格式。This is usually <code>wire</code> or <code>reg</code>. If you are declaring a input or output port, the type can additionally include the port type (e.g., <code>input</code> or <code>output</code>) as well. Some examples:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] w;         <span class="comment">// 8-bit wire</span></span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">4</span>:<span class="number">1</span>] x;         <span class="comment">// 4-bit reg</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">0</span>:<span class="number">0</span>] y;   <span class="comment">// 1-bit reg that is also an output port (this is still a vector)</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">3</span>:-<span class="number">2</span>] z;  <span class="comment">// 6-bit wire input (negative ranges are allowed)</span></span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] a;       <span class="comment">// 4-bit output wire. Type is &#x27;wire&#x27; unless specified otherwise.</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">0</span>:<span class="number">7</span>] b;         <span class="comment">// 8-bit wire where b[0] is the most-significant bit.</span></span><br><span class="line">上述就是显式指定数据类型。</span><br></pre></td></tr></table></figure>
<p>The <em>endianness</em> (or, informally, “direction”) of a vector is whether the least significant bit has a lower index (little-endian, e.g., [3:0]) or a higher index (big-endian, e.g., [0:3]). In Verilog, once a vector is declared with a particular endianness, it must always be used the same way. e.g., writing <code>vec[0:3]</code> when <code>vec</code> is declared <code>wire [3:0] vec;</code> is illegal. 我们要确保，如果声明数据类型时用的就是小端，那么在后面给变量赋值时，就要遵从小端顺序，用 <code>vec[0:3]</code> 。Being consistent with endianness is good practice, as weird bugs occur if vectors of different endianness are assigned or used together.这里也就是注意小端是[3:0]也就是0是最低位。（最低位拿到最低索引）</p>
<h4 id="Implicit-nets"><a href="#Implicit-nets" class="headerlink" title="Implicit nets"></a>Implicit nets</h4><p>Implicit nets are often a source of hard-to-detect bugs. In Verilog, net-type signals can be implicitly created by an <code>assign</code> statement or by attaching something undeclared to a module port. Implicit nets are always one-bit wires and causes bugs if you had intended to use a vector. Disabling creation of implicit nets can be done using the <code>`default_nettype none</code> directive.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] a, c;   <span class="comment">// Two vectors</span></span><br><span class="line"><span class="keyword">assign</span> a = <span class="number">3&#x27;b101</span>;  <span class="comment">// a = 101</span></span><br><span class="line"><span class="keyword">assign</span> b = a;       <span class="comment">// b =   1  implicitly-created wire</span></span><br><span class="line"><span class="keyword">assign</span> c = b;       <span class="comment">// c = 001  &lt;-- bug</span></span><br><span class="line">my_module i1 (d,e); <span class="comment">// d and e are implicitly one-bit wide if not declared.</span></span><br><span class="line">                    <span class="comment">// This could be a bug if the port was intended to be a vector.</span></span><br></pre></td></tr></table></figure>
<p>也就是尝试将向量a赋值给没有显式声明的b，verilog通常会隐式地创建一个单比特的线(wire)来存储结果。由于a是3位宽的向量，只有最低位a[0]会被赋值给b，所以b变成了单比特且值为1。</p>
<p>所以当b再被赋值给c时，由于c是一个3位宽的向量，所以导致了一个潜在的错误，由于位宽不匹配。</p>
<p>最后实例化了一个名为my_module的模块，并将端口d和e连接到该模块的端口。如果在模块内部没有像之前一样定义d和e的宽度。那么他们将同样被隐式地视为单比特线。这可能会导致问题，如果模块内部的端口本应该是向量而不是单比特。</p>
<p>而<code>default_nettype none</code>是一种设置，它告诉编译器不要隐式创建未声明信号，而是要求我们显式声明所有信号。</p>
<h4 id="Unpacked-vs-Packed-Arrays"><a href="#Unpacked-vs-Packed-Arrays" class="headerlink" title="Unpacked vs. Packed Arrays"></a>Unpacked vs. Packed Arrays</h4><p>你可能注意到，向量索引写在了向量名字的前面。这声明了数组的打包维度，其中的位被打包到一个blob中（这在模拟器中相关，但在硬件中无关）。未打包维度被声明在向量名之后。他们通常被用来声明内存指针，因为ECE253并没有覆盖内存数组，这门课中我们也没有用打包的指针。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] mem [<span class="number">255</span>:<span class="number">0</span>];<span class="comment">//这是256个未打包元素，每个元素是一个8比特的打包reg向量。</span></span><br><span class="line"><span class="keyword">reg</span> mem2 [<span class="number">28</span>:<span class="number">0</span>];<span class="number">29</span> unpacked elements, each of which is a <span class="number">1</span>-<span class="keyword">bit</span> <span class="keyword">reg</span>.</span><br></pre></td></tr></table></figure>
<h3 id="Accessing-Vector-Elements-Part-Select"><a href="#Accessing-Vector-Elements-Part-Select" class="headerlink" title="Accessing Vector Elements: Part-Select"></a>Accessing Vector Elements: Part-Select</h3><p>我们用向量名来访问一个向量。比如</p>
<p><code>assign w = a;</code></p>
<p>将整个4比特的a赋值分配给8比特向量w。如果等号左右两边不匹配，则会根据情况进行0扩展或者截断（truncated）。</p>
<p>所以，part-select operator可以被用来访问一个向量的一部分。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">w[<span class="number">3</span>:<span class="number">0</span>]<span class="comment">//w的低4位</span></span><br><span class="line">x[<span class="number">1</span>]<span class="comment">//x的最低位</span></span><br><span class="line">x[<span class="number">1</span>:<span class="number">1</span>]<span class="comment">//也是x的最低位</span></span><br><span class="line">z[-<span class="number">1</span>:-<span class="number">2</span>]<span class="comment">//z的最低两位</span></span><br><span class="line">b[<span class="number">3</span>:<span class="number">0</span>]<span class="comment">//非法！因为在上面我们的定义b向量是按照大端来赋值的！必须与声明匹配。</span></span><br><span class="line">b[<span class="number">0</span>:<span class="number">3</span>]<span class="comment">//b的高四位。</span></span><br><span class="line"><span class="keyword">assign</span> w[<span class="number">3</span>:<span class="number">0</span>] = b[<span class="number">0</span>:<span class="number">3</span>];<span class="comment">//显然是合法的因为w是小端，b是大端所以这样反过来赋值。分配b的高4位给w的低四位。</span></span><br></pre></td></tr></table></figure>
<h3 id="A-Bit-of-Practice"><a href="#A-Bit-of-Practice" class="headerlink" title="A Bit of Practice"></a>A Bit of Practice</h3><p>建立一个组合电路，使得能够分开输入字(16bits,[15:0])，分成低8位[7:0]和高8位[15:8]。</p>
<p>读完题显然知道这是小端序。</p>
<p>代码如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">default_nettype</span> none     </span><span class="comment">// Disable implicit nets. Reduces some types of bugs.</span></span><br><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] out_hi,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] out_lo );</span><br><span class="line">    <span class="keyword">assign</span> out_hi[<span class="number">7</span>:<span class="number">0</span>] = in[<span class="number">15</span>:<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">assign</span> out_lo[<span class="number">7</span>:<span class="number">0</span>] = in[<span class="number">7</span>:<span class="number">0</span>];<span class="comment">//就是简单赋值 </span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Vector2"><a href="#Vector2" class="headerlink" title="Vector2"></a>Vector2</h2><p>A 32-bit vector can be viewed as containing 4 bytes (bits [31:24], [23:16], etc.). Build a circuit that will reverse the <em>byte</em> ordering of the 4-byte word.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AaaaaaaaBbbbbbbbCcccccccDddddddd =&gt; DdddddddCcccccccBbbbbbbbAaaaaaaa</span><br></pre></td></tr></table></figure>
<p>显然我们只需要一段一段赋值即可</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] out );<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> out[<span class="number">31</span>:<span class="number">24</span>] = in[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> out[<span class="number">23</span>:<span class="number">16</span>] = in[<span class="number">15</span>:<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">assign</span> out[<span class="number">15</span>:<span class="number">8</span>] = in[<span class="number">23</span>:<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">assign</span> out[<span class="number">7</span>:<span class="number">0</span>] = in[<span class="number">31</span>:<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Vectorgates"><a href="#Vectorgates" class="headerlink" title="Vectorgates"></a>Vectorgates</h2><p>主要讲一下向量整体进行or运算，和两个向量中的8位分别进行or运算的区别。</p>
<p>Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of <code>b</code> in the upper half of <code>out_not</code> (i.e., bits [5:3]), and the inverse of <code>a</code> in the lower half.</p>
<h3 id="Bitwise-vs-Logical-Operators"><a href="#Bitwise-vs-Logical-Operators" class="headerlink" title="Bitwise vs. Logical Operators"></a>Bitwise vs. Logical Operators</h3><p>Earlier, we mentioned that there are bitwise and logical versions of the various boolean operators (e.g., <a target="_blank" rel="noopener" href="https://hdlbits.01xz.net/wiki/norgate">norgate</a>). When using vectors, the distinction between the two operator types becomes important. A bitwise operation between two N-bit vectors replicates the operation for each bit of the vector and produces a N-bit output, while a logical operation treats the entire vector as a boolean value (true = non-zero, false = zero) and produces a 1-bit output.</p>
<p>Look at the simulation waveforms at how the bitwise-OR and logical-OR differ.</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Vectorgates.png" alt="Vectorgates.png"></p>
<p>代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] out_or_bitwise,</span><br><span class="line">    <span class="keyword">output</span> out_or_logical,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">5</span>:<span class="number">0</span>] out_not</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> out_or_bitwise[<span class="number">2</span>] = a[<span class="number">2</span>] || b[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">assign</span> out_or_bitwise[<span class="number">1</span>] = a[<span class="number">1</span>] || b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">assign</span> out_or_bitwise[<span class="number">0</span>] = a[<span class="number">0</span>] || b[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> out_or_logical = a || b;</span><br><span class="line">    <span class="keyword">assign</span> out_not[<span class="number">5</span>:<span class="number">3</span>] = ~b[<span class="number">2</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> out_not[<span class="number">2</span>:<span class="number">0</span>] = ~a[<span class="number">2</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>当然我做的十分麻烦，标准答案如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] a, </span><br><span class="line">	<span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] b, </span><br><span class="line">	<span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] out_or_bitwise,</span><br><span class="line">	<span class="keyword">output</span> out_or_logical,</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">5</span>:<span class="number">0</span>] out_not</span><br><span class="line">);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">assign</span> out_or_bitwise = a | b;</span><br><span class="line">	<span class="keyword">assign</span> out_or_logical = a || b;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">assign</span> out_not[<span class="number">2</span>:<span class="number">0</span>] = ~a;	<span class="comment">// Part-select on left side is o.</span></span><br><span class="line">	<span class="keyword">assign</span> out_not[<span class="number">5</span>:<span class="number">3</span>] = ~b;	<span class="comment">//Assigning to [5:3] does not conflict with [2:0]</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>注意对比特操作或运算就用单竖线。并且可以用~直接对向量所有比特取反。</p>
<h2 id="Gates4"><a href="#Gates4" class="headerlink" title="Gates4"></a>Gates4</h2><p>Build a combinational circuit with four inputs, <code>in[3:0]</code></p>
<p>There are 3 outputs:</p>
<ul>
<li>out_and: output of a 4-input AND gate.</li>
<li>out_or: output of a 4-input OR gate.</li>
<li>out_xor: output of a 4-input XOR gate.</li>
</ul>
<p>代码如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> out_and,</span><br><span class="line">    <span class="keyword">output</span> out_or,</span><br><span class="line">    <span class="keyword">output</span> out_xor</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> out_and = in[<span class="number">0</span>]&amp;&amp;in[<span class="number">1</span>]&amp;&amp;in[<span class="number">2</span>]&amp;&amp;in[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> out_or = in[<span class="number">0</span>] || in[<span class="number">1</span>] || in[<span class="number">2</span>] || in[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> out_xor = in[<span class="number">0</span>] ^ in[<span class="number">1</span>] ^ in[<span class="number">2</span>] ^ in[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据选择器</span></span><br><span class="line"><span class="comment">//1.行为描述方式</span></span><br><span class="line"><span class="keyword">module</span> mux_2_to_1(a, b, out, outbar, sel);</span><br><span class="line">    <span class="keyword">input</span> a, b, sel;</span><br><span class="line">    <span class="keyword">output</span> out, outbar;<span class="comment">//分别定义了输入河输出接口</span></span><br><span class="line">    <span class="keyword">assign</span> out = sel ? a : b;<span class="comment">//也就是sel是1则选择a否则选择b</span></span><br><span class="line">    <span class="keyword">assign</span> outbar = ~out;<span class="comment">//把选出的另一个值取出</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.结构描述方式</span></span><br><span class="line"><span class="keyword">module</span> muxgate(a, b, out, outbar, sel);</span><br><span class="line">    <span class="keyword">input</span> a, b, sel;</span><br><span class="line">    <span class="keyword">output</span> out, outbar;</span><br><span class="line">    <span class="keyword">wire</span> out1, out2, selb;<span class="comment">//定义内部的三个连接点</span></span><br><span class="line">        <span class="keyword">and</span> a1 (out1, a, sel);</span><br><span class="line">        <span class="keyword">not</span> i1 (selb, sel);</span><br><span class="line">        <span class="keyword">and</span> a2 (out2, b, selb);</span><br><span class="line">        <span class="keyword">or</span> o1 (out, out1, out2);</span><br><span class="line">        <span class="keyword">assign</span> outbar = ~out;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Vector3"><a href="#Vector3" class="headerlink" title="Vector3"></a>Vector3</h2><p>部分选择被用来选择向量的一部分，连接符号{a, b, c}被用来创建大向量，通过连接小部分的向量。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">3&#x27;b111</span>, <span class="number">3&#x27;b000</span>&#125; =&gt; <span class="number">6&#x27;b111000</span></span><br><span class="line">&#123;<span class="number">1&#x27;b1</span>, <span class="number">1&#x27;b0</span>, <span class="number">3&#x27;b101</span>&#125; =&gt; <span class="number">5&#x27;b10101</span></span><br><span class="line">&#123;<span class="number">4&#x27;ha</span>, <span class="number">4&#x27;d10</span>&#125; =&gt; <span class="number">8&#x27;b10101010</span>     <span class="comment">// 4&#x27;ha and 4&#x27;d10 are both 4&#x27;b1010 in binary</span></span><br><span class="line"><span class="comment">//注意4&#x27;d表示4位10进制数</span></span><br></pre></td></tr></table></figure>
<p>连接需要知道每个分量的宽度（不然你怎么知道最后的长度呢）。因此，{1, 2, 3}是非法的并且在结果中，会有这样的错误消息：<code>unsized constants are not allowed in concatenations</code>.</p>
<p>连接符既可以被用在声明左边也可以被用在声明右边。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">23</span>:<span class="number">0</span>] out;</span><br><span class="line"><span class="keyword">assign</span> &#123;out[<span class="number">7</span>:<span class="number">0</span>], out[<span class="number">15</span>:<span class="number">8</span>]&#125; = in;<span class="comment">//用在了左边</span></span><br><span class="line"><span class="keyword">assign</span> out[<span class="number">15</span>:<span class="number">0</span>] = &#123;in[<span class="number">7</span>:<span class="number">0</span>], in[<span class="number">15</span>:<span class="number">8</span>]&#125;;<span class="comment">//用在了右边</span></span><br><span class="line"><span class="keyword">assign</span> out = &#123;in[<span class="number">7</span>:<span class="number">0</span>], in[<span class="number">15</span>:<span class="number">8</span>]&#125;;<span class="comment">//注意这个是不同的！因为out一共有23位！所以右边会被扩展，并且out[23:16]会是0。但是上两行，就没有被声明这些0.</span></span><br></pre></td></tr></table></figure>
<h3 id="A-bit-of-practice"><a href="#A-bit-of-practice" class="headerlink" title="A bit of practice"></a>A bit of practice</h3><p>给定一些输入向量，连接他们并且把他们分成一些输出向量。有6个5bit输入向量：a,b,c,d,e,f所以一共30bit的输入。有四个8bit的输出向量w,x,y,z一共是32bit。输出将会是输入向量加上比特<code>11</code>的连接。显然，30bit+2bit = 32bit正好与输出位数相同。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Vector3.png" alt="Vector3.png"></p>
<p>显然代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] a, b, c, d, e, f,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] w, x, y, z,</span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] input_concat;</span><br><span class="line">);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign &#123; ... &#125; = &#123; ... &#125;;</span></span><br><span class="line">    <span class="keyword">assign</span> input_concat[<span class="number">31</span>:<span class="number">0</span>] = &#123;a[<span class="number">4</span>:<span class="number">0</span>], b[<span class="number">4</span>:<span class="number">0</span>], c[<span class="number">4</span>:<span class="number">0</span>], d[<span class="number">4</span>:<span class="number">0</span>], e[<span class="number">4</span>:<span class="number">0</span>], f[<span class="number">4</span>:<span class="number">0</span>], <span class="number">2&#x27;b11</span>&#125;;</span><br><span class="line">    <span class="keyword">assign</span> w[<span class="number">7</span>:<span class="number">0</span>] = intput_concat[<span class="number">31</span>:<span class="number">24</span>];</span><br><span class="line">    <span class="keyword">assign</span> x[<span class="number">7</span>:<span class="number">0</span>] = intput_concat[<span class="number">23</span>:<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">assign</span> y[<span class="number">7</span>:<span class="number">0</span>] = intput_concat[<span class="number">15</span>:<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">assign</span> z[<span class="number">7</span>:<span class="number">0</span>] = intput_concat[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>还有一种更简单的</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接不用定义中间件，这样分配即可。</span><br><span class="line"><span class="keyword">assign</span> &#123;w[<span class="number">7</span>:<span class="number">0</span>], x[<span class="number">7</span>:<span class="number">0</span>], y[<span class="number">7</span>:<span class="number">0</span>], z[<span class="number">7</span>:<span class="number">0</span>]&#125; = &#123;a[<span class="number">4</span>:<span class="number">0</span>], b[<span class="number">4</span>:<span class="number">0</span>], c[<span class="number">4</span>:<span class="number">0</span>], d[<span class="number">4</span>:<span class="number">0</span>], e[<span class="number">4</span>:<span class="number">0</span>], f[<span class="number">4</span>:<span class="number">0</span>], <span class="number">2&#x27;b11</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="VectorOrr"><a href="#VectorOrr" class="headerlink" title="VectorOrr"></a>VectorOrr</h2><p>给定一个8比特输入向量[7:0]，反转它的比特顺序。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] in,</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">assign</span> &#123;out[<span class="number">0</span>],out[<span class="number">1</span>],out[<span class="number">2</span>],out[<span class="number">3</span>],out[<span class="number">4</span>],out[<span class="number">5</span>],out[<span class="number">6</span>],out[<span class="number">7</span>]&#125; = in[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">	其实我们完全可以用<span class="keyword">for</span>循环来做。</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>for循环描述电路行为而不是结构，因此只能使用他们在程序块内(比如always块)。这句话我也不是很理解，总是直接用循环即可。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)<span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)<span class="comment">//int 是systemVerilog语句，如果纯Verilog语句只能用integer</span></span><br><span class="line">    out[i] = in[<span class="number">8</span>-<span class="number">1</span>-i];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Generate-for 循环是一种用于在编译时生成硬件描述的机制，它与常规的过程性 for 循环不同，因为它并不执行操作，而是生成硬件结构。所以还可以用generate-for语句</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">generate</span> </span><br><span class="line">  <span class="keyword">genvar</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i = i + <span class="number">1</span>) <span class="keyword">begin</span>: my_block_name</span><br><span class="line">    <span class="keyword">assign</span> out[i] = in[<span class="number">8</span>-i-<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endgenerate</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>Generate-for 循环</strong>：<ul>
<li><strong>用途</strong>：用于生成硬件电路结构。</li>
<li><strong>执行时机</strong>：在编译时生成硬件结构，不在仿真时执行。</li>
<li><strong>示例用途</strong>：用于在硬件级别创建多个模块实例、连接信号等。</li>
</ul>
</li>
<li><strong>普通 for 循环</strong>：<ul>
<li><strong>用途</strong>：用于执行仿真时的操作和控制流程。</li>
<li><strong>执行时机</strong>：在仿真时执行循环内的操作，用于模拟电路的功能。</li>
<li><strong>示例用途</strong>：用于编写测试向量、控制电路行为、执行算法等。</li>
</ul>
</li>
</ol>
<p>当然，下面也是一个练习，给一个100-bit的输入向量[99:0], 反转bit顺序。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">99</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">99</span>:<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always</span> @(*)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">integer</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            out[i] = in[<span class="number">100</span>-<span class="number">1</span>-i];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还可以简化一下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">99</span>:<span class="number">0</span>] in,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">99</span>:<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">$bits</span>(out);i++)		<span class="comment">// $bits() 是一个系统函数，返回信号宽度。</span></span><br><span class="line">			out[i] = in[<span class="built_in">$bits</span>(out)-i-<span class="number">1</span>];	<span class="comment">// $bits(out) 显然返回100位宽。</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Replication-operator"><a href="#Replication-operator" class="headerlink" title="Replication operator"></a>Replication operator</h2><p>连接符允许从大向量中连接向量。有时你想被连接起来的字符重复好多次，但是单纯手敲好几遍太麻烦了。所以才有了这种方式。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125;           <span class="comment">// 5&#x27;b11111 (or 5&#x27;d31 or 5&#x27;h1f)</span></span><br><span class="line">&#123;<span class="number">2</span>&#123;a,b,c&#125;&#125;          <span class="comment">// The same as &#123;a,b,c,a,b,c&#125;</span></span><br><span class="line">&#123;<span class="number">3&#x27;d5</span>, &#123;<span class="number">2</span>&#123;<span class="number">3&#x27;d6</span>&#125;&#125;&#125;<span class="comment">//首先是一个101，然后是两个110，把这三个连接到一起。</span></span><br></pre></td></tr></table></figure>
<p>下面练习。</p>
<p>看到复制运算符的一个常见情况是将较小的数字符号扩展为较大的数字，同时保留其有符号值。这是通过将较小数字的符号位（最高有效位）复制到左侧来完成的。比如</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4&#x27;b0101</span>(<span class="number">5</span>)到<span class="number">8</span><span class="keyword">bit</span>结果<span class="number">8&#x27;b00000101</span>(<span class="number">5</span>)</span><br><span class="line">还有</span><br><span class="line"><span class="number">4&#x27;b1101</span>(-<span class="number">3</span>)到<span class="number">8</span><span class="keyword">bit</span>结果<span class="number">8&#x27;b11111101</span>(-<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>我们要构建一个电路，用符号扩展一个8bit的数到32bits.这显然需要一个24bits扩展的符号位，然后接上原来数字本身。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] out );<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign out = &#123; replicate-sign-bit , the-input &#125;;</span></span><br><span class="line">    <span class="keyword">assign</span> out = &#123;&#123;<span class="number">24</span>&#123;in[<span class="number">7</span>]&#125;&#125;, in[<span class="number">7</span>:<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="more-replication"><a href="#more-replication" class="headerlink" title="more replication"></a>more replication</h2><p>给定5个1bit信号a, b, c, d, e计算所有25对1-bit比较，在25个输出向量中。输出将会是1，如果两bit相同。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out[<span class="number">24</span>] = ~a ^ a;<span class="comment">//a == a,所以out[24]总是1。因为先取反再异或，如果相同肯定是1，不同的话，取反就相同了，异或就是0了。</span></span><br><span class="line">out[<span class="number">23</span>] = ~a ^ b;</span><br><span class="line">...</span><br><span class="line">out[<span class="number">0</span>] = ~e ^ e;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Vector5.png" alt="Vector5.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> a, b, c, d, e,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">24</span>:<span class="number">0</span>] out );<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The output is XNOR of two vectors created by </span></span><br><span class="line">    <span class="comment">// concatenating and replicating the five inputs.</span></span><br><span class="line">    <span class="comment">// assign out = ~&#123; ... &#125; ^ &#123; ... &#125;;</span></span><br><span class="line">    <span class="keyword">assign</span> out[<span class="number">24</span>:<span class="number">20</span>] = ~&#123;a, a, a ,a, a&#125; ^ &#123;a, b, c, d, e&#125;;</span><br><span class="line">    <span class="keyword">assign</span> out[<span class="number">19</span>:<span class="number">15</span>] = ~&#123;b, b, b, b, b&#125; ^ &#123;a, b, c ,d, e&#125;;</span><br><span class="line">    <span class="keyword">assign</span> out[<span class="number">14</span>:<span class="number">10</span>] = ~&#123;c, c, c, c, c&#125; ^ &#123;a, b, c, d, e&#125;;</span><br><span class="line">    <span class="keyword">assign</span> out[<span class="number">9</span>:<span class="number">5</span>] = ~&#123;d, d, d, d, d&#125; ^ &#123;a, b, c, d, e&#125;;</span><br><span class="line">    <span class="keyword">assign</span> out[<span class="number">4</span>:<span class="number">0</span>] = ~&#123;e, e, e, e, e&#125; ^ &#123;a, b, c, d, e&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个非常麻烦和傻的答案，当然，这是我写的，下面我们看简单的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">	<span class="keyword">input</span> a, b, c, d, e,</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">24</span>:<span class="number">0</span>] out</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">wire</span>[<span class="number">24</span>:<span class="number">0</span>] top, bottom;</span><br><span class="line">  <span class="keyword">assign</span> top = &#123; &#123;<span class="number">5</span>&#123;a&#125;&#125;, &#123;<span class="number">5</span>&#123;b&#125;&#125;, &#123;<span class="number">5</span>&#123;c&#125;&#125;, &#123;<span class="number">5</span>&#123;d&#125;&#125;, &#123;<span class="number">5</span>&#123;e&#125;&#125;&#125;;</span><br><span class="line">  <span class="keyword">assign</span> bottom = &#123; <span class="number">5</span>&#123;a, b, c, d, e&#125; &#125;;</span><br><span class="line">  <span class="keyword">assign</span> out = ~top ^ bottom;<span class="comment">//这里会进行bit级别的逻辑运算！</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Module-也就是设计一个芯片模块"><a href="#Module-也就是设计一个芯片模块" class="headerlink" title="Module(也就是设计一个芯片模块)"></a>Module(也就是设计一个芯片模块)</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mod_a ( <span class="keyword">input</span> in1, <span class="keyword">input</span> in2, <span class="keyword">output</span> out );</span><br><span class="line">    <span class="comment">// Module body</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其中的三个参数表示了三个端口，显然in1, in2是两个输入，output out是一个输出。</p>
<p>模块的层级通过创建在一个模块内部创建模块而体现，只要所有的被使用的模块属于同一个项目（编译器也就知道去哪里找模块了）。</p>
<p>一个模块的代码并不是在另一个模块的内部。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Module.png" alt="Module.png"></p>
<p>下面是两种把信号连接到模块端口的办法。</p>
<p>1.通过位置</p>
<p>这个语法和c语言非常相似。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mod_a instance1(wa, wb, wc)</span><br></pre></td></tr></table></figure>
<p>这样实例化了一个具有type mod_a的module，并且给它了一个实例名字instance1，然后连接信号wa(在新module之外的),连接到第一个端口(in1)，同理wb连接到第二个端口in2，如图所示。wc就连到输出端口out。</p>
<p>这种语法的一个缺点就是，如果模块的接口列表改变了，所有关于这个模块的实例都要被找到，并且改变，匹配新的模块模板。</p>
<p>2.通过名字</p>
<p>通过名称连接信号到模块的端口， 允许wires保持正确的连接即使端口列表改变了。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mod_a instance2(<span class="variable">.out</span>(wc), <span class="variable">.in1</span>(wa), <span class="variable">.in2</span>(wb));</span><br></pre></td></tr></table></figure>
<p>上述初始化了一个mod_a类型的模块，叫做instance2。注意到端口的顺序并不是按顺序的，因为连接将会被对应到正确的端口名，无论端口在端口列表中的位置如何。显然这种方式更好。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">	<span class="keyword">input</span> a,</span><br><span class="line">	<span class="keyword">input</span> b,</span><br><span class="line">	<span class="keyword">output</span> out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在顶层模块中创建一个mod_a模块并且实例化位inst1&quot;, 通过名字连接端口:</span></span><br><span class="line">	mod_a inst1 ( </span><br><span class="line">    <span class="variable">.in1</span>(a), 	<span class="comment">// mod_a的端口1连接到上层的a</span></span><br><span class="line">    <span class="variable">.in2</span>(b),	<span class="comment">// 端口in2连接到上层的b</span></span><br><span class="line">    <span class="variable">.out</span>(out)	<span class="comment">// mod_a的out连接到外面top_module的out.</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	// Create an instance of &quot;mod_a&quot; named &quot;inst2&quot;, and connect ports by position:</span></span><br><span class="line"><span class="comment">	mod_a inst2 ( a, b, out );	// The three wires are connected to ports in1, in2, and out, respectively.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>实际上就是大模块里面定义了一个小模块。下面是一个练习题目。</p>
<p>给定了一个内部模块命名为mod_a，有2个输出和4个输入，我们必须要连接6个端口通过位置或者名称，连接到我们的外部模块top_module上，外部模块的输出和输入分别为out1, out2, a, b, c, d。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Module_pos.png" alt="Module pos.png"></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">错误：<span class="keyword">module</span> top_module(<span class="keyword">input</span> a, <span class="keyword">input</span> b, <span class="keyword">input</span> c, <span class="keyword">input</span> d, <span class="keyword">output</span> out1, <span class="keyword">output</span> out2);</span><br><span class="line">  mod_a instance1(</span><br><span class="line">    <span class="variable">.in</span>(a),</span><br><span class="line">    <span class="variable">.in</span>(b),</span><br><span class="line">    <span class="variable">.in</span>(c),</span><br><span class="line">    <span class="variable">.in</span>(d),</span><br><span class="line">    <span class="variable">.out</span>(out1),</span><br><span class="line">    <span class="variable">.out</span>(out2)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//这样便会报错！因为in无法指定具体是哪个端口，所以我们只能用位置命名！</span></span><br><span class="line"><span class="keyword">module</span> top_module(<span class="keyword">input</span> a, <span class="keyword">input</span> b, <span class="keyword">input</span> c, <span class="keyword">input</span> d, <span class="keyword">output</span> out1, <span class="keyword">output</span> out2);</span><br><span class="line">  mod_a instance1(out1, out2, a, b, c, d);</span><br><span class="line"><span class="keyword">endmodule</span><span class="comment">//注意里面的顺序，是根据mod_a定义时的声明顺序来的。因为module mod_a ( output, output, input, input, input, input );</span></span><br></pre></td></tr></table></figure>
<p>但是如果电路图这样给出。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Module_name.png" alt="Module name.png"></p>
<p>我们便可以用上面的命名方式，来连接两个模块的端口了！</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(<span class="keyword">input</span> a, <span class="keyword">input</span> b, <span class="keyword">input</span> c, <span class="keyword">input</span> d, <span class="keyword">output</span> out1, <span class="keyword">output</span> out2);</span><br><span class="line">  mod_a instance1(</span><br><span class="line">    <span class="variable">.in1</span>(a),</span><br><span class="line">    <span class="variable">.in2</span>(b),</span><br><span class="line">    <span class="variable">.in3</span>(c),</span><br><span class="line">    <span class="variable">.in4</span>(d),</span><br><span class="line">    <span class="variable">.out1</span>(out1),</span><br><span class="line">    <span class="variable">.out2</span>(out2)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Module-shift"><a href="#Module-shift" class="headerlink" title="Module shift"></a>Module shift</h2><p>这是设计一个移位寄存器，初始化三个锁存器，连接在一起，并且将三个的时钟信号连接到一起。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Module_shift.png" alt="Module shift.png"></p>
<p>其中锁存器的模块命名为<code>module my_dff ( input clk, input d, output q );</code></p>
<p>注意想要完成内部链接，我们需要定义一些wires。注意我们对线和实例的命名，必须是唯一的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module ( <span class="keyword">input</span> clk, <span class="keyword">input</span> d, <span class="keyword">output</span> q );</span><br><span class="line">    <span class="keyword">wire</span> dff_1_out;</span><br><span class="line">    <span class="keyword">wire</span> dff_2_out;</span><br><span class="line">    my_dff instant1(clk, d, dff_1_out);</span><br><span class="line">    my_dff instant2(clk, dff_1_out, dff_2_out);</span><br><span class="line">    my_dff instant3(clk, dff_2_out, q);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//细细理解，当然这里可以定义三条线，最后再用q连接第三条线，只不过两条线就足够了。</span></span><br></pre></td></tr></table></figure>
<p>下面是拓展问题，上面我们的线和端口只是朴素的线，这次我们把它换成向量。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Module_shift8.png" alt="Module shift8.png"></p>
<p>这里我们使用my_dff8，有两个输入和一个输出，把他们联结在一起，此外创建一个4-1的复用器（数据选择器）来根据sel[1:0]两位，决定输出哪一个数据。本质上，<code>sel</code>选择延迟输入的周期数，从零到三个时钟周期。</p>
<p>其中my_dff8的定义方式为<code>my_dff8 ( input clk, input [7:0] d, output [7:0] q );</code></p>
<p>但是数据选择器并没有提供，我们需要先练习创建一个16bit宽的，9-1的数据选择器。sel=0选择a，sel=1选择b，等等。对于没有使用的情况（sel=9~15）输出位置1。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] a, b, c, d, e, f, g, h, i,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] sel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] out );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(sel)</span><br><span class="line">            <span class="number">4&#x27;b0000</span>: out = a;  <span class="comment">// 当sel=0选择数据a</span></span><br><span class="line">            <span class="number">4&#x27;b0001</span>: out = b;  <span class="comment">// When sel is 1, choose input b</span></span><br><span class="line">            <span class="number">4&#x27;b0010</span>: out = c;  <span class="comment">// When sel is 2, choose input c</span></span><br><span class="line">            <span class="number">4&#x27;b0011</span>: out = d;  <span class="comment">// When sel is 3, choose input d</span></span><br><span class="line">            <span class="number">4&#x27;b0100</span>: out = e;  <span class="comment">// When sel is 4, choose input e</span></span><br><span class="line">            <span class="number">4&#x27;b0101</span>: out = f;  <span class="comment">// When sel is 5, choose input f</span></span><br><span class="line">            <span class="number">4&#x27;b0110</span>: out = g;  <span class="comment">// When sel is 6, choose input g</span></span><br><span class="line">            <span class="number">4&#x27;b0111</span>: out = h;  <span class="comment">// When sel is 7, choose input h</span></span><br><span class="line">            <span class="number">4&#x27;b1000</span>: out = i;</span><br><span class="line">            <span class="keyword">default</span>: out = <span class="number">16&#x27;b1111111111111111</span>;  <span class="comment">// 也就是选择8-15时全部置1.</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>或者标准答案给出了一个省略default的写法，如下，在中间部分替换一下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">		out = &#x27;<span class="number">1</span>;		<span class="comment">// &#x27;1 is a special literal syntax for a number with all bits set to 1.</span></span><br><span class="line">						<span class="comment">// &#x27;0, &#x27;x, and &#x27;z are also valid.</span></span><br><span class="line">						<span class="comment">// I prefer to assign a default value to &#x27;out&#x27; instead of using a</span></span><br><span class="line">						<span class="comment">// default case.</span></span><br><span class="line">		<span class="keyword">case</span> (sel)</span><br><span class="line">			<span class="number">4&#x27;h0</span>: out = a;</span><br><span class="line">			<span class="number">4&#x27;h1</span>: out = b;</span><br><span class="line">			<span class="number">4&#x27;h2</span>: out = c;</span><br><span class="line">			<span class="number">4&#x27;h3</span>: out = d;</span><br><span class="line">			<span class="number">4&#x27;h4</span>: out = e;</span><br><span class="line">			<span class="number">4&#x27;h5</span>: out = f;</span><br><span class="line">			<span class="number">4&#x27;h6</span>: out = g;</span><br><span class="line">			<span class="number">4&#x27;h7</span>: out = h;</span><br><span class="line">			<span class="number">4&#x27;h8</span>: out = i;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>回到本题，因为是4选1，所以只需要sel两位即可。看题目中所给，正好是两位[1:0]。说明没问题啦。</p>
<p>在创建线的时候，我们要创建成向量模式了！</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module ( </span><br><span class="line">    <span class="keyword">input</span> clk, </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] d, </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] sel, </span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] q </span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] dff_1_output;<span class="comment">//因为定义中输入输出都是8位了</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] dff_2_output;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] dff_3_output;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] select_out;</span><br><span class="line">    my_dff8 instant1(clk, d[<span class="number">7</span>:<span class="number">0</span>], dff_1_output[<span class="number">7</span>:<span class="number">0</span>]);</span><br><span class="line">    my_dff8 instant2(clk, dff_1_output[<span class="number">7</span>:<span class="number">0</span>], dff_2_output[<span class="number">7</span>:<span class="number">0</span>]);</span><br><span class="line">    my_dff8 instant3(clk, dff_2_output[<span class="number">7</span>:<span class="number">0</span>], dff_3_output[<span class="number">7</span>:<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(*)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(sel)</span><br><span class="line">            <span class="number">2&#x27;b00</span>: select_out[<span class="number">7</span>:<span class="number">0</span>] = d[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">            <span class="number">2&#x27;b01</span>: select_out = dff_1_output;</span><br><span class="line">            <span class="number">2&#x27;b10</span>: select_out = dff_2_output;</span><br><span class="line">            <span class="number">2&#x27;b11</span>: select_out[<span class="number">7</span>:<span class="number">0</span>] = dff_3_output[<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">default</span>: select_out[<span class="number">7</span>:<span class="number">0</span>] = <span class="number">8&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span> q = select_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>一定要注意定义向量的顺序！先定义范围，在安排名字！犯错好几次了！</p>
<h2 id="Module-add"><a href="#Module-add" class="headerlink" title="Module add"></a>Module add</h2><p>我们被给出了一个16位加法器，产生了16位加法。初始化两个并且创造一个32位加法器。其中一个16位加法器计算低16位，在接收第一个加法器的进位之后，第二个加法器计算高16位。假设我们的32位加法器不需要考虑输入进位，即第一个16模块的输入进位设为0，和输出进位。（但是内部的模块需要考虑这些，比如第二个16加法器模块就要算上第一个的输出进位）。</p>
<p>16位加法器的定义如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> add16 ( <span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] a, <span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] b, <span class="keyword">input</span> cin, <span class="keyword">output</span>[<span class="number">15</span>:<span class="number">0</span>] sum, <span class="keyword">output</span> cout );</span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Module_add.png" alt="Module add.png"></p>
<p>代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] sum</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] out_1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] out_2;</span><br><span class="line">    <span class="keyword">wire</span> c_out_1;</span><br><span class="line">    <span class="keyword">wire</span> c_out_2;</span><br><span class="line">    add16 instant1(a[<span class="number">15</span>:<span class="number">0</span>], b[<span class="number">15</span>:<span class="number">0</span>], <span class="number">0</span>, out_1[<span class="number">15</span>:<span class="number">0</span>], c_out_1);</span><br><span class="line">    add16 instant2(a[<span class="number">31</span>:<span class="number">16</span>], b[<span class="number">31</span>:<span class="number">16</span>], c_out_1, out_2[<span class="number">15</span>:<span class="number">0</span>], c_out_2);</span><br><span class="line">    <span class="keyword">assign</span> sum[<span class="number">15</span>:<span class="number">0</span>] = out_1[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> sum[<span class="number">31</span>:<span class="number">16</span>] = out_2[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>在这个练习中，我们将会创造一个两个等级的电路。我们的<code>top_module</code>将会初始化两个16位加法器，就像上面给出的，然后每个加法器将会初始化16个1位加法器，所以我们要写两个模块：<code>top_module</code>和<code>add1</code>。</p>
<p>就像上面的练习，我们被给出了一个16位加法器来完成一个16位加法。我必须初始化两个来创造一个32位加法。</p>
<p>连接两个16位加法器如图所示。对16位加法器的声明如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> add16 ( <span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] a, <span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] b, <span class="keyword">input</span> cin, <span class="keyword">output</span>[<span class="number">15</span>:<span class="number">0</span>] sum, <span class="keyword">output</span> cout );</span><br></pre></td></tr></table></figure>
<p>在每个16位加法器内，16个1位加法器被初始化来完成这个运算。这个1位加法器的声明如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> add1 ( <span class="keyword">input</span> a, <span class="keyword">input</span> b, <span class="keyword">input</span> cin, <span class="keyword">output</span> sum, <span class="keyword">output</span> cout );</span><br></pre></td></tr></table></figure>
<p>总而言之，在这个设计中，有三个模块：</p>
<p><code>top_module</code>包含了两个16位加法器。</p>
<p><code>add16</code>一个16位加法器包含了16个1位加法器。</p>
<p><code>add1</code>一个1位全加器。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Module_fadd.png" alt="Module fadd.png"></p>
<p>代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] sum</span><br><span class="line">);<span class="comment">//</span></span><br><span class="line">    <span class="comment">//要用线定义多个中间进位信号</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] out_1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] out_2;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] c_out_1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] c_out_2;</span><br><span class="line">    <span class="comment">//add16 instant1(a[15:0], b[15:0], 0, out_1[15:0], c_out_1[15:0]);</span></span><br><span class="line">    <span class="comment">//add16 instant2(a[31:16], b[31:16], c_out_1, out_2[15:0], c_out_2[15:0]);</span></span><br><span class="line">    </span><br><span class="line">    add1 instant(a[<span class="number">0</span>], b[<span class="number">0</span>], <span class="number">0</span>, out_1[<span class="number">0</span>], c_out_1[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">genvar</span> i;<span class="comment">//for循环实例化16个全加器</span></span><br><span class="line">    <span class="keyword">generate</span> </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; <span class="number">16</span>; i=i+<span class="number">1</span>) <span class="keyword">begin</span>: gen_add1</span><br><span class="line">            add1 instant(a[i], b[i], c_out_1[i-<span class="number">1</span>], out_1[i], c_out_1[i]);<span class="comment">//把第一个里面剩下的进行循环</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line">    </span><br><span class="line">    add1 instant12(a[<span class="number">16</span>], b[<span class="number">16</span>], c_out_1[<span class="number">15</span>], out_2[<span class="number">0</span>], c_out_2[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">genvar</span> j;</span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">16</span>; j = j + <span class="number">1</span>) <span class="keyword">begin</span>: gen_add2</span><br><span class="line">            add1 instant(a[j + <span class="number">16</span>], b[j + <span class="number">16</span>], c_out_2[j-<span class="number">1</span>], out_2[j], c_out_2[j]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line">    <span class="keyword">assign</span> sum[<span class="number">31</span>:<span class="number">16</span>] = c_out_2[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">assign</span> sum[<span class="number">15</span>:<span class="number">0</span>] = c_out_1[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> add1 ( <span class="keyword">input</span> a, <span class="keyword">input</span> b, <span class="keyword">input</span> cin,   <span class="keyword">output</span> sum, <span class="keyword">output</span> cout );</span><br><span class="line">    <span class="keyword">wire</span> x1, x2, x3;</span><br><span class="line">    <span class="keyword">xor</span> (x1, a, b);</span><br><span class="line">    <span class="keyword">xor</span> (sum, x1, cin);<span class="comment">//结果</span></span><br><span class="line">    <span class="comment">//计算进位</span></span><br><span class="line">    <span class="keyword">and</span> (x2, a, b);</span><br><span class="line">    <span class="keyword">or</span> (x3, x2, (a &amp; cin));</span><br><span class="line">    <span class="keyword">or</span> (cout, x3, (b &amp; cin));<span class="comment">//这样俩俩计算进位即可。</span></span><br><span class="line"><span class="comment">// Full adder module here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>写了半天，结果白费功夫，肯定不能这样套娃啊，已经模块化设计了。</p>
<p>正确答案如下！</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] sum</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> c_out_1;</span><br><span class="line">    <span class="keyword">wire</span> c_out_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化两个16位加法器</span></span><br><span class="line">    add16 instant1(a[<span class="number">15</span>:<span class="number">0</span>], b[<span class="number">15</span>:<span class="number">0</span>], <span class="number">0</span>, sum[<span class="number">15</span>:<span class="number">0</span>], c_out_1);</span><br><span class="line">    add16 instant2(a[<span class="number">31</span>:<span class="number">16</span>], b[<span class="number">31</span>:<span class="number">16</span>], c_out_1, sum[<span class="number">31</span>:<span class="number">16</span>], c_out_2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> add1 (</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">input</span> cin,</span><br><span class="line">    <span class="keyword">output</span> sum,</span><br><span class="line">    <span class="keyword">output</span> cout</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> x1, x2, x3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算和</span></span><br><span class="line">    <span class="keyword">xor</span> (x1, a, b);</span><br><span class="line">    <span class="keyword">xor</span> (sum, x1, cin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算进位</span></span><br><span class="line">    <span class="keyword">and</span> (x2, a, b);</span><br><span class="line">    <span class="keyword">or</span> (x3, x2, (a &amp; cin));</span><br><span class="line">    <span class="keyword">or</span> (cout, x3, (b &amp; cin));</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意此题只是想让我们完成最下面的add1模块的定义即可！而add1主要考察进位的表示，显然三个加数俩俩与酒可以了！</p>
<h2 id="carry-select-adder"><a href="#carry-select-adder" class="headerlink" title="carry-select adder"></a>carry-select adder</h2><p>上面的合成加法器，也叫做波纹进位加法器（ripple carry adder）的缺点是，加法器计算进位的延迟相当的慢，并且第二个加法器要等第一个加法器的carry out计算出来之后，才能进行计算它自己的carry out，这让整个加法器都慢了许多。一种改进的方法如下图所示：</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Module_cseladd.png" alt="Module cseladd.png"></p>
<p>第一个加法器像以前一样，不变，但是我们倍增第二个加法器，其中一个假定carry in = 0，另一个假定carry in = 1，然后用快速2-1数据选择器来选择哪个结果是正确的。</p>
<p>在这个练习中，我们被提供和上次一行的16位加法器。这次我们必须要初始化三个16位加法器，并且使用16位2-1数据选择器，来实现进位选择加法器。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> add16 ( <span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] a, <span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] b, <span class="keyword">input</span> cin, <span class="keyword">output</span>[<span class="number">15</span>:<span class="number">0</span>] sum, <span class="keyword">output</span> cout );</span><br></pre></td></tr></table></figure>
<p>连接起来的模块如图所示。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Module_cseladd-20231009155711932.png" alt="Module cseladd.png"></p>
<p>显然并不是很难，用到了我们上面数据选择器</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] sum</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> c_out_1, c_out_2, c_out_3;<span class="comment">//c_out1就是sel信号</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] out_1, out_2;</span><br><span class="line">    add16 instant1(a[<span class="number">15</span>:<span class="number">0</span>], b[<span class="number">15</span>:<span class="number">0</span>], <span class="number">0</span>, sum[<span class="number">15</span>:<span class="number">0</span>], c_out_1);</span><br><span class="line">    add16 instant2(a[<span class="number">31</span>:<span class="number">16</span>], b[<span class="number">31</span>:<span class="number">16</span>], <span class="number">0</span>, out_1[<span class="number">15</span>:<span class="number">0</span>], c_out_2);</span><br><span class="line">    add16 instant3(a[<span class="number">31</span>:<span class="number">16</span>], b[<span class="number">31</span>:<span class="number">16</span>], <span class="number">1</span>, out_2[<span class="number">15</span>:<span class="number">0</span>], c_out_3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(c_out_1)</span><br><span class="line">            <span class="number">1&#x27;b1</span>: sum[<span class="number">31</span>:<span class="number">16</span>] = out_2;</span><br><span class="line">            <span class="number">1&#x27;b0</span>: sum[<span class="number">31</span>:<span class="number">16</span>] = out_1;</span><br><span class="line">            <span class="keyword">default</span>: sum[<span class="number">31</span>:<span class="number">16</span>] = <span class="number">16&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Module-add-sub-加减法器"><a href="#Module-add-sub-加减法器" class="headerlink" title="Module add-sub(加减法器)"></a>Module add-sub(加减法器)</h2><p>一个加减法器可以通过把一个加法器选择性地取反一位输入来实现，这和取反输入再加1是一样的。最终是一个可以执行两种操作的电路：(a + b + 0)和(a + ~b + 1)也就是用了补码的操作。</p>
<p>这里同样我们被提供了一个像之前一样的16位加法器。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> add16 ( <span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] a, <span class="keyword">input</span>[<span class="number">15</span>:<span class="number">0</span>] b, <span class="keyword">input</span> cin, <span class="keyword">output</span>[<span class="number">15</span>:<span class="number">0</span>] sum, <span class="keyword">output</span> cout );</span><br></pre></td></tr></table></figure>
<p>用一个32位宽的xor来反转b输入，当sub位是1的时候（执行减法）。也可以写作b[31:0] xor sub重复32次。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Module_addsub.png" alt="Module addsub.png"></p>
<p>并且把sub input连接到cin端口。</p>
<p>下面是代码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">input</span> sub,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] sum</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">wire</span> c_out_1, c_out_2;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] sub_32 = &#123;<span class="number">32</span>&#123;sub&#125;&#125;;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] reversed_b;</span><br><span class="line">    <span class="keyword">assign</span> reversed_b[<span class="number">31</span>:<span class="number">0</span>] = b[<span class="number">31</span>:<span class="number">0</span>] ^ sub_32[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">    add16 instant1(a[<span class="number">15</span>:<span class="number">0</span>], reversed_b[<span class="number">15</span>:<span class="number">0</span>], sub, sum[<span class="number">15</span>:<span class="number">0</span>], c_out_1);</span><br><span class="line">    add16 instant2(a[<span class="number">31</span>:<span class="number">16</span>], reversed_b[<span class="number">31</span>:<span class="number">16</span>], c_out_1, sum[<span class="number">31</span>:<span class="number">16</span>], c_out_2);   </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>但是这里有一个小问题我之前给reversed_b赋值用的</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">xor</span>(reversed_b[<span class="number">31</span>:<span class="number">0</span>], b[<span class="number">31</span>:<span class="number">0</span>], sub_32[<span class="number">31</span>:<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>结果出现错误，这是为什么。</p>
<h2 id="Always-block1"><a href="#Always-block1" class="headerlink" title="Always block1"></a>Always block1</h2><p>因为数字电路就是由带线连接的逻辑门构成的，任何电路可以被表示为一些模块和声明的组合。然而有时这并不是最方便的描述电路的方法，Procedures(包括always, initial, task, function)这些语句帮助我们描述电路。</p>
<p>对于仿真硬件，下面两种always的块都可以：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">combinational: <span class="keyword">always</span> @(*)</span><br><span class="line">clocked: <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br></pre></td></tr></table></figure>
<p>将always块组合起来和赋值语句是等价的，因此我们可以用两种方式表示组合电路。而选择其中哪一种就要看语法的方便程度了。过程块内部代码的语法和外部代码不同。过程块具有更丰富的语句集(if-then, case)。</p>
<p>比如下面两种语句描述同一个赋值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) out2 = a&amp;b | c^d;</span><br><span class="line"><span class="keyword">assign</span> out1 = a&amp;b | c^d;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Alwayscomb.png" alt="永远梳子.png"></p>
<p>如图所示，对于<code>assign</code>赋值，变量类型是wire，而对于<code>always</code>赋值，变量类型是reg。这些变量类型和合成的硬件无关。</p>
<p>下面是练习代码，用两种语句写一个与门。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> out_assign,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> out_alwaysblock</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> out_assign = a &amp; b;</span><br><span class="line">    <span class="keyword">always</span> @(*) out_alwaysblock = a &amp; b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="Always-block2"><a href="#Always-block2" class="headerlink" title="Always block2"></a>Always block2</h2><p>对于硬件仿真，有两种always块</p>
<p>combinational: always @(*)</p>
<p>clocked: always @(posege clk)</p>
<p>下面的时钟块也是创建一个组合逻辑块，而且还在组合逻辑块的输出处创建一组触发器(flip-flop)(或者寄存器reg)。逻辑块的输出不是立即可见，而是仅仅在下一个(posege clk)之后立即可见。</p>
<h3 id="blocking-vs-non-blocking-assignment"><a href="#blocking-vs-non-blocking-assignment" class="headerlink" title="blocking vs non-blocking assignment"></a>blocking vs non-blocking assignment</h3><p><code>Continuous</code>assignment: <code>assign x = y;</code>只能用于不在procedures(always块)中时。</p>
<p>procedual <code>blocking</code>assignment比如<code>x = y;</code>只能用在procedure中。</p>
<p>procedual <code>non-blocking</code>assignment比如<code>x &lt;= y;</code>也只能用在procedure中。</p>
<p>在一个组合always块中，用<code>blocking</code>声明。在<code>clocked</code>always块中，用<code>non-blocking</code>声明。</p>
<p>下面是一个练习。</p>
<p>使用三种方式构建异或门。（分配语句，组合always块，clocked always块）注意，clocked always块与其他两个不同，有一个触发器(flip-flop)所以输出被延迟。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Alwaysff.png" alt="总是ff.png"></p>
<p>代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> out_assign,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> out_always_comb,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> out_always_ff   );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> out_assign = a ^ b;</span><br><span class="line">    <span class="keyword">always</span> @(*) out_always_comb = a ^ b;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) out_always_ff = a ^ b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="if-statement"><a href="#if-statement" class="headerlink" title="if-statement"></a>if-statement</h2><p>我们用if语句实现2-1数据选择器。如果条件正确输出1，条件错误输出0。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="keyword">begin</span></span><br><span class="line">        out = x;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        out = y;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>或者等驾于用一个三幕运算符。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> out = (condition) ? x: y;</span><br></pre></td></tr></table></figure>
<p>根据下面真值表，给出电路语句。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">sel_b1</th>
<th style="text-align:left">sel_b2</th>
<th style="text-align:left">out_assign out_always</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">a</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">a</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">a</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">b</td>
</tr>
</tbody>
</table>
</div>
<p>在电路中用两种方式，一种用assign直接赋值，另一种用procedual中的if statement。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">input</span> sel_b1,</span><br><span class="line">    <span class="keyword">input</span> sel_b2,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">wire</span> out_assign,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> out_always   ); </span><br><span class="line">    <span class="keyword">assign</span> out_assign = (sel_b1 &amp; sel_b2) ? b:a;</span><br><span class="line">    <span class="keyword">always</span> @(*)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(sel_b1 &amp; sel_b2) <span class="keyword">begin</span></span><br><span class="line">            out_always = b;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            out_always = a;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>非常简单！</p>
<h3 id="A-common-source-of-errors-How-to-avoid-making-latches（锁存器）"><a href="#A-common-source-of-errors-How-to-avoid-making-latches（锁存器）" class="headerlink" title="A common source of errors: How to avoid making latches（锁存器）"></a>A common source of errors: How to avoid making latches（锁存器）</h3><p>下面的代码，不正确的操作，创建了一个锁存器。修改bug，以至于你只有在它真正过载的时候才关闭电脑，并且停止驾驶当你到达目的地准备加油时。</p>
<p><img src="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Always_if2.png" alt="img"></p>
<p>这是语句描述出来的错误电路，并不是你想要的逻辑。这样会使电脑默认关机了。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*)<span class="keyword">begin</span> </span><br><span class="line">  <span class="keyword">if</span>(cpu_overhead)</span><br><span class="line">    shut_off_computer = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(~arrived)</span><br><span class="line">    keep_driving = ~gas_tank_empty;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">在第一个电路中如果过载就关机了，那么如果没过载，默认也关机了，所以相当于创造了一个锁存器存住了默认执行语句。</span><br><span class="line">在第二个电路默认空油也会驾驶。</span><br></pre></td></tr></table></figure>
<p>也就是我们需要一个else语句，否则else情况就会默认执行前面的语句。</p>
<p>修改之后如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span>      cpu_overheated,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> shut_off_computer,</span><br><span class="line">    <span class="keyword">input</span>      arrived,</span><br><span class="line">    <span class="keyword">input</span>      gas_tank_empty,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> keep_driving  ); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cpu_overheated) <span class="keyword">begin</span></span><br><span class="line">           shut_off_computer = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            shut_off_computer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (~arrived) <span class="keyword">begin</span></span><br><span class="line">           keep_driving = ~gas_tank_empty;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            keep_driving = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><p>我们已经比较熟悉了，因为前面的例子中已经提到过，所以我们只需要来练习一下即可。</p>
<p>创建一个6选1的数据选择器，当选择键sel在0-5之间，选择对应的数据输出。并且给定输入数据和输出数据都是4位。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module ( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] sel, </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] data0,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] data1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] data2,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] data3,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] data4,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] data5,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] out   );<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(*) <span class="keyword">begin</span>  <span class="comment">// This is a combinational circuit</span></span><br><span class="line">        <span class="keyword">case</span>(sel)</span><br><span class="line">            <span class="number">3&#x27;b000</span>: out = data0;</span><br><span class="line">            <span class="number">3&#x27;b001</span>: out = data1;</span><br><span class="line">            <span class="number">3&#x27;b010</span>: out = data2;</span><br><span class="line">            <span class="number">3&#x27;b011</span>: out = data3;</span><br><span class="line">            <span class="number">3&#x27;b100</span>: out = data4;</span><br><span class="line">            <span class="number">3&#x27;b101</span>: out = data5;</span><br><span class="line">            <span class="keyword">default</span>: out = <span class="number">4&#x27;b0000</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h2><p>一个优先编码器是一个组合逻辑电路，当给定一个输入向量，输出是向量中的第一个电平位1的比特。比如，一个8bit的优先编码器被给定了输入<code>8&#39;b10010000</code>将会输出<code>3&#39;d4</code>因为bit[4]是第一个电平位1的电平。</p>
<p>下面构建一个优先编码器。当然，如果所有输入都没有1这个位，那么就输出0。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] pos  );</span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(in)</span><br><span class="line">            <span class="number">4&#x27;b0000</span>: pos = <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="number">4&#x27;b0001</span>: pos = <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="number">4&#x27;b0010</span>: pos = <span class="number">2&#x27;d1</span>;</span><br><span class="line">            <span class="number">4&#x27;b0011</span>: pos = <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="number">4&#x27;b0100</span>: pos = <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="number">4&#x27;b0101</span>: pos = <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="number">4&#x27;b0110</span>: pos = <span class="number">2&#x27;d1</span>;</span><br><span class="line">            <span class="number">4&#x27;b0111</span>: pos = <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="number">4&#x27;b1000</span>: pos = <span class="number">2&#x27;d3</span>;</span><br><span class="line">            <span class="number">4&#x27;b1001</span>: pos = <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="number">4&#x27;b1010</span>: pos = <span class="number">2&#x27;d1</span>;</span><br><span class="line">            <span class="number">4&#x27;b1011</span>: pos = <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="number">4&#x27;b1100</span>: pos = <span class="number">2&#x27;d2</span>;</span><br><span class="line">            <span class="number">4&#x27;b1101</span>: pos = <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="number">4&#x27;b1110</span>: pos = <span class="number">2&#x27;d1</span>;</span><br><span class="line">            <span class="number">4&#x27;b1111</span>: pos = <span class="number">2&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">default</span>: pos = <span class="number">2&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>显然这样表示比较麻烦，我们更倾向于16进制表示，会简单很多。</p>
<h2 id="Always-CaseZ"><a href="#Always-CaseZ" class="headerlink" title="Always CaseZ"></a>Always CaseZ</h2><p>创建一个优先编码器应对8位输入。给定一个8位向量，输出应该汇报出1出现的第一个位置。报告0如果输入向量</p>
<p>但是8位输入的话，我们就要在case中写256个情况，未免太多了点。其实我们可以把256种情况减小到9种，如果其中的一些项包含了一些无关紧要的bits。<strong>这就是caseZ做的事情：他在比较中将具有值z的位设置为无关位。</strong></p>
<p>比如上一个例子中，就可以简写成</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">casez</span> (in[<span class="number">3</span>:<span class="number">0</span>])</span><br><span class="line">        <span class="number">4&#x27;bzzz1</span>: out = <span class="number">0</span>;   <span class="comment">// in[3:1] can be anything</span></span><br><span class="line">        <span class="number">4&#x27;bzz1z</span>: out = <span class="number">1</span>;</span><br><span class="line">        <span class="number">4&#x27;bz1zz</span>: out = <span class="number">2</span>;</span><br><span class="line">        <span class="number">4&#x27;b1zzz</span>: out = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">default</span>: out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>运行程序的时候所有16种情况会自己进去配对，配到哪种就输出对应的值，但是问题来了，比如4’b1111这对于上面的情况都吻合，该输出什么呢？此时应该输出匹配到的第一项，也就是out = 0.后面的项不再匹配。</p>
<p>注意：匹配符号用?或者z都可以！</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] pos</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">casez</span>(in)</span><br><span class="line">        <span class="number">8</span>&#x27;b???????<span class="number">1</span>: pos = <span class="number">3&#x27;d0</span>;</span><br><span class="line">        <span class="number">8</span>&#x27;b??????<span class="number">10</span>: pos = <span class="number">3&#x27;d1</span>;</span><br><span class="line">        <span class="number">8</span>&#x27;b?????<span class="number">100</span>: pos = <span class="number">3&#x27;d2</span>;</span><br><span class="line">        <span class="number">8</span>&#x27;b????<span class="number">1000</span>: pos = <span class="number">3&#x27;d3</span>;</span><br><span class="line">        <span class="number">8</span>&#x27;b???<span class="number">10000</span>: pos = <span class="number">3&#x27;d4</span>;</span><br><span class="line">        <span class="number">8</span>&#x27;b??<span class="number">100000</span>: pos = <span class="number">3&#x27;d5</span>;<span class="comment">//用z或者用?都可以！</span></span><br><span class="line">        <span class="number">8</span>&#x27;b?<span class="number">1000000</span>: pos = <span class="number">3&#x27;d6</span>;</span><br><span class="line">        <span class="number">8&#x27;b10000000</span>: pos = <span class="number">3&#x27;d7</span>;</span><br><span class="line">        <span class="keyword">default</span>: pos = <span class="number">3&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：此时的case一定要改成casez</strong></p>
<h2 id="Always-no-latches"><a href="#Always-no-latches" class="headerlink" title="Always no latches"></a>Always no latches</h2><p>假设您正在构建一个电路来处理游戏中 PS/2 键盘的扫描码。鉴于收到的扫描码的最后两个字节，您需要指示键盘上的方向键之一是否已被按下。这涉及一个相当简单的映射，可以将其实现为具有四种情况的 case 语句（或 if-elseif）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Scancode [15:0]</th>
<th style="text-align:left">Arrow key</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>16&#39;he06b</code></td>
<td style="text-align:left">left arrow</td>
</tr>
<tr>
<td style="text-align:left"><code>16&#39;he072</code></td>
<td style="text-align:left">down arrow</td>
</tr>
<tr>
<td style="text-align:left"><code>16&#39;he074</code></td>
<td style="text-align:left">right arrow</td>
</tr>
<tr>
<td style="text-align:left"><code>16&#39;he075</code></td>
<td style="text-align:left">up arrow</td>
</tr>
<tr>
<td style="text-align:left">Anything else</td>
<td style="text-align:left">none</td>
</tr>
</tbody>
</table>
</div>
<p>您的电路有 1 个 16 位输入和 4 个输出。构建该电路来识别这四个扫描码并断言正确的输出。</p>
<p>为了避免创建锁存器，我们要在所有可能的条件下为所有的输出分配一个值。解决他的简单方法就是在case语句之前为输出分配一个默认值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    up = <span class="number">1&#x27;b0</span>; down = <span class="number">1&#x27;b0</span>; left = <span class="number">1&#x27;b0</span>; right = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">case</span> (scancode)</span><br><span class="line">        ... <span class="comment">// Set to 1 as necessary.</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>题目代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synthesis verilog_input_version verilog_2001</span></span><br><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] scancode,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> left,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> down,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> right,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> up  ); </span><br><span class="line">    <span class="keyword">always</span> @(*)<span class="keyword">begin</span></span><br><span class="line">        up = <span class="number">1&#x27;b0</span>;down = <span class="number">1&#x27;b0</span>;left = <span class="number">1&#x27;b0</span>;right = <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">case</span>(scancode)</span><br><span class="line">            <span class="number">16&#x27;he06b</span>: left = <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="number">16&#x27;he072</span>: down = <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="number">16&#x27;he074</span>: right = <span class="number">1&#x27;b1</span>;</span><br><span class="line">            <span class="number">16&#x27;he075</span>: up = <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>实际上也不难！之前的例子中已经出现了提前赋值的情况！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://www.mathming.ltd">Spencer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.mathming.ltd/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/">http://www.mathming.ltd/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/FPGA/">FPGA</a></div><div class="post_share"><div class="social-share" data-image="https://images.pexels.com/photos/1903702/pexels-photo-1903702.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/19/2023-9-19-FPGA%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" src="https://images.pexels.com/photos/1509534/pexels-photo-1509534.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">FPGA工具学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/"><img class="next-cover" src="https://images.pexels.com/photos/1903702/pexels-photo-1903702.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Matlab wireless communication foundation</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Getting-started"><span class="toc-number">1.</span> <span class="toc-text">Getting started</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Zero"><span class="toc-number">1.1.</span> <span class="toc-text">Zero</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#verilog-Language"><span class="toc-number">2.</span> <span class="toc-text">verilog Language</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#simple-wire"><span class="toc-number">2.1.</span> <span class="toc-text">simple wire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wire-4"><span class="toc-number">2.2.</span> <span class="toc-text">wire 4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Not-gate"><span class="toc-number">2.3.</span> <span class="toc-text">Not gate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Andgate"><span class="toc-number">2.4.</span> <span class="toc-text">Andgate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Norgate"><span class="toc-number">2.5.</span> <span class="toc-text">Norgate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xnorgate"><span class="toc-number">2.6.</span> <span class="toc-text">Xnorgate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Declaring-wires"><span class="toc-number">3.</span> <span class="toc-text">Declaring wires</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7458-chip"><span class="toc-number">4.</span> <span class="toc-text">7458 chip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector0-%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%8C%E5%B0%86%E5%A4%9A%E4%B8%AA%E7%BA%BF%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">Vector0(其实就是数组，将多个线合并成一个数组)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector1"><span class="toc-number">6.</span> <span class="toc-text">Vector1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Declaring-Vectors"><span class="toc-number">6.1.</span> <span class="toc-text">Declaring Vectors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Implicit-nets"><span class="toc-number">6.1.1.</span> <span class="toc-text">Implicit nets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unpacked-vs-Packed-Arrays"><span class="toc-number">6.1.2.</span> <span class="toc-text">Unpacked vs. Packed Arrays</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Accessing-Vector-Elements-Part-Select"><span class="toc-number">6.2.</span> <span class="toc-text">Accessing Vector Elements: Part-Select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-Bit-of-Practice"><span class="toc-number">6.3.</span> <span class="toc-text">A Bit of Practice</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector2"><span class="toc-number">7.</span> <span class="toc-text">Vector2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vectorgates"><span class="toc-number">8.</span> <span class="toc-text">Vectorgates</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitwise-vs-Logical-Operators"><span class="toc-number">8.1.</span> <span class="toc-text">Bitwise vs. Logical Operators</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Gates4"><span class="toc-number">9.</span> <span class="toc-text">Gates4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">数据选择器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector3"><span class="toc-number">11.</span> <span class="toc-text">Vector3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-bit-of-practice"><span class="toc-number">11.1.</span> <span class="toc-text">A bit of practice</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VectorOrr"><span class="toc-number">12.</span> <span class="toc-text">VectorOrr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Replication-operator"><span class="toc-number">13.</span> <span class="toc-text">Replication operator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#more-replication"><span class="toc-number">14.</span> <span class="toc-text">more replication</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Module-%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E8%8A%AF%E7%89%87%E6%A8%A1%E5%9D%97"><span class="toc-number">15.</span> <span class="toc-text">Module(也就是设计一个芯片模块)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Module-shift"><span class="toc-number">16.</span> <span class="toc-text">Module shift</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Module-add"><span class="toc-number">17.</span> <span class="toc-text">Module add</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">17.1.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#carry-select-adder"><span class="toc-number">18.</span> <span class="toc-text">carry-select adder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Module-add-sub-%E5%8A%A0%E5%87%8F%E6%B3%95%E5%99%A8"><span class="toc-number">19.</span> <span class="toc-text">Module add-sub(加减法器)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Always-block1"><span class="toc-number">20.</span> <span class="toc-text">Always block1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Always-block2"><span class="toc-number">21.</span> <span class="toc-text">Always block2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#blocking-vs-non-blocking-assignment"><span class="toc-number">21.1.</span> <span class="toc-text">blocking vs non-blocking assignment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if-statement"><span class="toc-number">22.</span> <span class="toc-text">if-statement</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-common-source-of-errors-How-to-avoid-making-latches%EF%BC%88%E9%94%81%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">22.1.</span> <span class="toc-text">A common source of errors: How to avoid making latches（锁存器）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#case%E8%AF%AD%E5%8F%A5"><span class="toc-number">23.</span> <span class="toc-text">case语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#case-2"><span class="toc-number">24.</span> <span class="toc-text">case 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Always-CaseZ"><span class="toc-number">25.</span> <span class="toc-text">Always CaseZ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Always-no-latches"><span class="toc-number">26.</span> <span class="toc-text">Always no latches</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://images.pexels.com/photos/1903702/pexels-photo-1903702.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Spencer</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'mSxoclNsLL8NLtvo34kDJbBy-MdYXbMMI',
      appKey: 'tLnjWwSLTZNRpGzOL7BMgXfN',
      avatar: 'monsterid',
      serverURLs: 'https://msxoclns.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><a href="https://beian.miit.gov.cn/" target="_blank" class="is-center">冀ICP备2021024675号-1</a><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>