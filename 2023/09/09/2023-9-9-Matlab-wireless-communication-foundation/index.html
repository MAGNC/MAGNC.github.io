<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Matlab wireless communication foundation | Spencer</title><meta name="author" content="Spencer"><meta name="copyright" content="Spencer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Matlab wireless communication foundationQAM modulationWe use Matlab toolbox to realize QAM modulation easily. 12345678srcBits &amp;#x3D; randi([0, 1], 20000, 1"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.mathming.ltd/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-NFDHX1L800"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-NFDHX1L800');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":10,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Spencer","link":"Link: ","source":"Source: Spencer","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Matlab wireless communication foundation',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-10 19:13:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">159</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">60</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">36</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-gallery"></i><span> Gallery</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images.pexels.com/photos/1903702/pexels-photo-1903702.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Spencer</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-gallery"></i><span> Gallery</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Matlab wireless communication foundation</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-09-08T16:00:00.000Z" title="Created 2023-09-09 00:00:00">2023-09-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-09-10T11:13:48.100Z" title="Updated 2023-09-10 19:13:48">2023-09-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/communication-systems/">communication systems</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Matlab wireless communication foundation"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Matlab-wireless-communication-foundation"><a href="#Matlab-wireless-communication-foundation" class="headerlink" title="Matlab wireless communication foundation"></a>Matlab wireless communication foundation</h1><h2 id="QAM-modulation"><a href="#QAM-modulation" class="headerlink" title="QAM modulation"></a>QAM modulation</h2><p>We use Matlab toolbox to realize QAM modulation easily.</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], <span class="number">20000</span>, <span class="number">1</span>);<span class="comment">%列向量，信源，而且注意16QAM是4位一组，所以2000应该为4的倍数</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>);</span><br><span class="line">scatterplot(modOut);</span><br><span class="line"><span class="comment">%画出星座图</span></span><br><span class="line">demodOut = qamdemod(chanOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>);</span><br><span class="line">check = <span class="built_in">isequal</span>(srcBits, demodOut);</span><br><span class="line"><span class="built_in">disp</span>(check);</span><br></pre></td></tr></table></figure>
<p>Here is the QAM graph.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910003431995.png" alt="image-20230910003431995"></p>
<h2 id="QAM-modulation-and-AWGN-Additive-White-Gauss-Noise-channel"><a href="#QAM-modulation-and-AWGN-Additive-White-Gauss-Noise-channel" class="headerlink" title="QAM modulation and AWGN(Additive White Gauss Noise)channel"></a>QAM modulation and AWGN(Additive White Gauss Noise)channel</h2><p>脚本如下</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], <span class="number">20000</span>, <span class="number">1</span>);<span class="comment">%设置信源</span></span><br><span class="line">modOrder = <span class="number">16</span>;<span class="comment">%设置调制电平等级，也就是4bits.</span></span><br><span class="line"></span><br><span class="line">snr1 = <span class="number">1.5</span>;<span class="comment">%设置一个糟糕的信噪比，当然，后面为了实验，我们会改动信噪比。</span></span><br><span class="line">modOut1 = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>,<span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>,<span class="built_in">true</span>);<span class="comment">%进行qam调制</span></span><br><span class="line"><span class="comment">%注意这里我们设置调制信号的平均功率为1</span></span><br><span class="line">chanOut1 = awgn(modOut1, snr1);<span class="comment">%通过awgn信道。</span></span><br><span class="line">scatterplot(chanOut1);<span class="comment">%画出散点图</span></span><br><span class="line">demodOut1 = qamdemod(chanOut1, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);<span class="comment">%进行解调</span></span><br><span class="line">check = <span class="built_in">isequal</span>(srcBits, demodOut1);<span class="comment">%检查信源和收到的解调信号是否相同。</span></span><br><span class="line"><span class="built_in">disp</span>(check);</span><br><span class="line"></span><br><span class="line">snr2 = <span class="number">20</span>;<span class="comment">%看信噪比为20时的正确率</span></span><br><span class="line">modOut2 = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line">chanOut2 = awgn(modOut2, snr2);</span><br><span class="line">scatterplot(chanOut2);</span><br><span class="line">demodOut2 = qamdemod(chanOut2, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line">check = <span class="built_in">isequal</span>(srcBits, chanOut2);</span><br><span class="line"><span class="built_in">disp</span>(check);</span><br></pre></td></tr></table></figure>
<h2 id="Calculate-Bit-Error-Rate-BER"><a href="#Calculate-Bit-Error-Rate-BER" class="headerlink" title="Calculate Bit Error Rate(BER)"></a>Calculate Bit Error Rate(BER)</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">numBits = <span class="number">20000</span>;</span><br><span class="line">modOrder = <span class="number">16</span>;<span class="comment">%the same parameters</span></span><br><span class="line"><span class="comment">%Create source signal</span></span><br><span class="line">srcBits= randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%Apply AWGN</span></span><br><span class="line">SNR = <span class="number">10</span>; <span class="comment">%dB</span></span><br><span class="line">chanOut = awgn(modOut, SNR);</span><br><span class="line">scatterplot(chanOut);<span class="comment">%draw the scatter graph of passing AWGN</span></span><br><span class="line"></span><br><span class="line">demodOut = qamdemod(chanOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line">isBitError = srcBits ~= demodOut;<span class="comment">%Now we compare the source bits and the bits from %demodulation.</span></span><br><span class="line"><span class="comment">%Output a array, 0 represents the two bits of srcBits and demodOut are the same, vice versa.</span></span><br><span class="line">numBitError = nnz(isBitError);</span><br><span class="line"><span class="comment">%calculate the number of 1</span></span><br><span class="line"><span class="built_in">disp</span>(BER);</span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910003223366.png" alt="image-20230910003223366"></p>
<p>Obviously, if we add the AWGN channel, then the BER is very large, and we have to improve our SNR to cancel it.</p>
<p>When we change BER into 20dB, let’s see the graph.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910003344406.png" alt="image-20230910003344406"></p>
<p>The bit can be distinguished now!</p>
<h2 id="Matched-Filter"><a href="#Matched-Filter" class="headerlink" title="Matched Filter"></a>Matched Filter</h2><p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910180157139.png" alt="image-20230910180157139"></p>
<p>All wireless communication signals must occupy a designated frequency band, much like how vehicles occupy a lane in a highway. If the <strong>signal’s energy extend beyond that band, it interferes the signals have the frequencies that be above or below your signal. </strong></p>
<p><strong>A transmitter filter makes sure that your transmitted signal stays within its designated band.</strong></p>
<p>On the other hand, the receiver also filters its input signal. Here, <strong>the filter will reduce the noise power that the downstream processing must handle.</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910184047636.png" alt="image-20230910184047636"></p>
<p>Since both transmitter and receiver filter the signals, <strong>it’s important that the two filters have matching frequency responses.</strong> These <strong>matched filters provide optimum performance in the presence of noise</strong>, <strong>because they maximize the signal to noise ratio of the output.</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910184400751.png" alt="image-20230910184400751"></p>
<p>There are many types of matched filters to choose from, we use commomly used <strong>Raised Cosine Filter,</strong> because it <strong>elimates inner-symbol interference</strong> that filtering can introduce.</p>
<p><strong>Reason: In the time domain, when you filter, the filter’s inpulse response can smear one symbol into the next, which can distort it!</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910184718412.png" alt="image-20230910184718412"></p>
<p>A Raised Cosine Impulse Response <strong>has a convenient property</strong>, the peak of one filter’s symbol occurs the <strong>zero crossings</strong>(其他波在此处0值) of the filter’s symbols that come before and after it.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910184823109.png" alt="image-20230910184823109"></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910185036367.png" alt="image-20230910185036367"></p>
<p><strong>So！Zero ISI!</strong></p>
<p>For implementation, since you need <strong>two filters</strong>, its convenient for their <strong>composite response to be the raised Cosined Filter response</strong>, so then use a Square Root Raised Cosine Filter for each,</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910185352296.png" alt="image-20230910185352296"></p>
<p>and there you have it!</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910185422435.png" alt="image-20230910185422435"></p>
<p><strong>Band limited on the front end, noise reduction on the backend, and zero ISI with the composite Raised Cosine Filter.</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">numBits = <span class="number">20000</span>;</span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>,<span class="built_in">true</span>);</span><br><span class="line"><span class="comment">%匹配滤波器我们用raisedcosinefilter,形状和sample函数差不多，我们将其拆成两个部分，</span></span><br><span class="line"><span class="comment">%输入滤波器和输出滤波器，所以每个部分用其方根即可！</span></span><br><span class="line"><span class="comment">%下面这个就已经是方根！</span></span><br><span class="line">txFilt = comm.RaisedCosineTransmitFilter;</span><br><span class="line">rxFilt = comm.RaisedCosineReceiveFilter;<span class="comment">%</span></span><br><span class="line">txFiltOut = txFilt(modOut);</span><br><span class="line"></span><br><span class="line">SNR = <span class="number">7</span>;</span><br><span class="line">chanOut = awgn(txFiltOut, SNR, <span class="string">&quot;measured&quot;</span>);</span><br><span class="line"><span class="comment">%measured调整信号功率，因为经过了滤波器。</span></span><br><span class="line">rxFiltOut = rxFilt(chanOut);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&quot;rxFiltOut&quot;</span>, <span class="string">&quot;var&quot;</span>)</span><br><span class="line">    scatterplot(rxFiltOut);</span><br><span class="line">    demodOut = qamdemod(rxFiltOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%下面创建一个功率谱分析仪，查看发射滤波器输出和AWGN信道输出的功率谱，无噪声信号为黄色，</span></span><br><span class="line"><span class="comment">%加AWGN噪声的信号为蓝色。</span></span><br><span class="line">specAn = dsp.SpectrumAnalyzer(<span class="string">&quot;NumInputPorts&quot;</span>, <span class="number">2</span>, <span class="string">&quot;SpectralAverages&quot;</span>, <span class="number">50</span>, <span class="string">&quot;ShowLegend&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line">specAn(txFiltOut, chanOut);</span><br></pre></td></tr></table></figure>
<h2 id="Mathpath-signal-recession"><a href="#Mathpath-signal-recession" class="headerlink" title="Mathpath signal recession"></a>Mathpath signal recession</h2><p>In wireless communications, the transmitted signal generally has <strong>reflected off many different surfaces before reaches the receiver</strong>.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910190031442.png" alt="image-20230910190031442"></p>
<p>These reflections resolve a phenomenon called multipath. <strong>Multipath basically means the transmitted signal has travelled a multiple different path by the time it reaches the receiver.</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910190234525.png" alt="image-20230910190234525"></p>
<p>Each path changes the signal while it’s on its way. For example, it could have a different gain or take longer to arrive.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910190418709.png" alt="image-20230910190418709"></p>
<p>As a result, the <strong>receiver gets multiple superimposed copies.And sees a time smear version of a transmitted signal.</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910190602544.png" alt="image-20230910190602544"></p>
<p><strong>Mathematically, it’s simply the sum of the impulse responses for the various path, including the time delay and gain and phase change for each path.</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910190848353.png" alt="image-20230910190848353"></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910190911026.png" alt="image-20230910190911026"></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%Single Carrier Link with Multipath Channel</span></span><br><span class="line">numBits = <span class="number">20000</span>;</span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">bitsPerSymbol = <span class="built_in">log2</span>(modOrder);</span><br><span class="line"><span class="comment">%每个符号有4位</span></span><br><span class="line">txFilt = comm.RaisedCosineTransmitFilter;</span><br><span class="line">rxFilt = comm.RaisedCosineReceiveFilter;</span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line">modOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="comment">%完成基本调制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%多径信道相当于FIR滤波器，也就是多个离散时间点上的冲击响应的和，也就是相当于信号卷积</span></span><br><span class="line"><span class="comment">%上一个sinc函数，sinc上每个离散时间点的值相当于一条径，并且多径我们认为它是有限条路径。</span></span><br><span class="line"><span class="comment">%而FIR滤波器在matlab中可以用列向量来表示。</span></span><br><span class="line">txFiltOut = txFilt(modOut);</span><br><span class="line"></span><br><span class="line">spacing = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">7</span>);</span><br><span class="line">mpChan = [<span class="number">0.8</span>, spacing, <span class="number">-0.5</span>, spacing, <span class="number">0.34</span>].&#x27;;</span><br><span class="line"><span class="comment">%或者是spacing = zeros[7, 1];mpChan = [0.8; spacing; -0.5; spacing; 0.34];</span></span><br><span class="line"><span class="comment">%也可以表示列向量</span></span><br><span class="line"><span class="built_in">disp</span>(mpChan);</span><br><span class="line">stem(mpChan);<span class="comment">%这就相当于多径信道的冲激响应</span></span><br><span class="line"></span><br><span class="line">mpChanOut = filter(mpChan, <span class="number">1</span>, txFiltOut);</span><br><span class="line"><span class="comment">%这里是过滤波器，把mpChan看成滤波器，进行卷积运算，FIR滤波器的分母是1，这是显然的</span></span><br><span class="line"><span class="comment">%最后一个参数表示对txFiltOut操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%先经过多径！再经过awgn信道！牢记</span></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&quot;mpChanOut&quot;</span>, <span class="string">&quot;var&quot;</span>)</span><br><span class="line">    SNR = <span class="number">15</span>;</span><br><span class="line">    chanOut = awgn(mpChanOut, SNR, <span class="string">&quot;measured&quot;</span>);</span><br><span class="line">    rxFiltOut = rxFilt(chanOut);</span><br><span class="line">    scatterplot(rxFiltOut);</span><br><span class="line">    title(<span class="string">&quot;Receive last RaisedCosine txFilter Output&quot;</span>);</span><br><span class="line">    demodOut = qamdemod(rxFiltOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%calculate the BER</span></span><br><span class="line"></span><br><span class="line">    delayInSymbols = txFilt.FilterSpanInSymbols / <span class="number">2</span> + rxFilt.FilterSpanInSymbols / <span class="number">2</span>;</span><br><span class="line">    delayInBits = delayInSymbols * bitsPerSymbol;</span><br><span class="line">    srcAligned = srcBits(<span class="number">1</span>:(<span class="keyword">end</span> - delayInBits));</span><br><span class="line">    demodAligned = demodOut((delayInBits + <span class="number">1</span>):<span class="keyword">end</span>);</span><br><span class="line">    numBitErrors = nnz(srcAligned ~= demodAligned);<span class="comment">%误码个数</span></span><br><span class="line">    BER = numBitErrors / <span class="built_in">length</span>(srcAligned);</span><br><span class="line">    <span class="built_in">disp</span>(BER)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%查看发射信号的频谱和信道输出。发射信号为黄色，而含噪多径信号为蓝色。</span></span><br><span class="line"><span class="comment">%接收到的信号的频谱的通带中有一个&quot;缺口”，这会使单载波波形发生显著扭曲。这种现象称为频率选择性多径，因为信道衰减或增益的水平取决于频率。</span></span><br><span class="line"><span class="comment">%下面利用频谱分析仪查看频率选择性衰落！</span></span><br><span class="line">specAn = dsp.SpectrumAnalyzer(<span class="string">&quot;NumInputPorts&quot;</span>, <span class="number">2</span>, <span class="string">&quot;SpectralAverages&quot;</span>, <span class="number">50</span>, <span class="string">&quot;ShowLegend&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line">specAn(txFiltOut, chanOut)</span><br><span class="line"><span class="comment">%chanOut相当于经过多径和awgn的共同作用之后的结果。</span></span><br><span class="line"><span class="comment">%txFiltOut只是刚刚经过匹配滤波器确保无码间干扰的结果</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910191131840.png" alt="image-20230910191131840"></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910191111978.png" alt="image-20230910191111978"></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910191158729.png" alt="image-20230910191158729"></p>
<h2 id="OFDM-Orthogonal-Frequency-Division-Multiplexing"><a href="#OFDM-Orthogonal-Frequency-Division-Multiplexing" class="headerlink" title="OFDM(Orthogonal Frequency Division Multiplexing)"></a>OFDM(Orthogonal Frequency Division Multiplexing)</h2><p>The multiple carriers are used to tramsmit data, each carrier has different frequency, in OFDM, according to Nyquist Bandwidth, the bandwidth efficiency has been improved and it can guarantee no inter-symbol interference(ISI)!</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/SouthEast.png" alt="img"></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%This is a simple OFDM system, using IFFT as a modulator, FFT as a demodulator.</span></span><br><span class="line">numBits = <span class="number">32768</span>;<span class="comment">%because this is a power of 2.</span></span><br><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line">qamModout = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line">scatterplot(qamModOut);<span class="comment">%draw a basic QAM constellation.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%passing OFDM</span></span><br><span class="line">ofdmModOut = ifft(qamModOut);<span class="comment">%It is equal to add OFDM in the source.</span></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&quot;ofdmModOut&quot;</span>, <span class="string">&quot;var&quot;</span>)</span><br><span class="line">	SNR = <span class="number">20</span>;</span><br><span class="line">	chanOut = awgn(ofdmModOut, SNR, <span class="string">&quot;measured&quot;</span>);<span class="comment">%transmit OFDM data adding AWGN</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ofdmDemodOut = fft(chanOut);</span><br><span class="line">scatterplot(ofdmDemodOut);<span class="comment">%draw the scatter diagram</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&quot;ofdmDemodOut&quot;</span>, <span class="string">&quot;var&quot;</span>)</span><br><span class="line">	qamDemodOut = qamdemod(chanOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line">	numBitErrors = nnz(srcBits ~= qamDemodOut);<span class="comment">%calculate Bits Error Rate</span></span><br><span class="line">	BER = numBitErrors / numBits;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%we can adjust SNR(dB)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910015043144.png" alt="image-20230910015043144"></p>
<p>This is the OFDM-demodulated signal.</p>
<p>Let’s see the frequency-magnitude graph of OFDM.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910110545602.png" alt="image-20230910110545602"></p>
<p>So what makes orthogonality in OFDM? Let’s zoom in to find the answer.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910110638698.png" alt="image-20230910110638698"></p>
<p><strong>The peak of each carrier is precisely at the zero crossing of all the others, which means none of the sub-carriers interfere with each others.</strong></p>
<p>And each carrier with $a_m$ as the cofficient, so the addition of the carriers can be </p>
<script type="math/tex; mode=display">
s(k) = \sum_{m=0}^{N-1} a_m e^{j2\pi (\frac{mk}{N})}</script><p><strong>In fact it is a IDFT, which can be efficiently implemented with the IFFT!</strong> So the simplest possible OFDM link uses the IFFT in the transmitter, followed by the FFT in the receiver!</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910111333748.png" alt="image-20230910111333748"></p>
<p>But it doesn’t actually help much with the multipath channel. A channel is basically a filter, ideally, <strong>that filter will be spectrally flat across the bandwidth of the signal.</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910111719043.png" alt="image-20230910111719043"></p>
<p>Then you can compensate for the channel signal loss and phase change with the simple complex gain in the receiver.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910111945501.png" alt="image-20230910111945501"></p>
<p>But a multipath channel spectrum can vary across the signal’s bandwidth, this causes the <strong>frequency selected fading(频率选择性衰落)</strong>, where different frequencies fade different amounts.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910112413638.png" alt="image-20230910112413638"></p>
<p>The receiver needs an <strong>equalizer to remove all the peaks and valleys created by the channel.</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910112550506.png" alt="image-20230910112550506"></p>
<p>The secret of the OFDM receiver is that how it performs the equalization. <strong>It can increase of decrease the gain of different frequency, </strong>to create the best listening experience!</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910112719297.png" alt="image-20230910112719297"></p>
<p>OFDM turns the high rates signal into parallel low rates signals. Each low-rate signal has a narrow bandwidth. So it encounters a channel whose spectra is relatively flat!</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910113053700.png" alt="image-20230910113053700"></p>
<p>That means the equalizer can simply <strong>apply a complex gain, and to each sub-carrier seperately</strong> , removing the peaks and valleys.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910113247685.png" alt="image-20230910113247685"></p>
<p>And since this <strong>equalization happens in the frequency domain, implementation is easy!</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910152131665.png" alt="image-20230910152131665"></p>
<p>You can estimate the channel, then simply divide to get the estimate of the transmitted signal.</p>
<script type="math/tex; mode=display">
\hat{S}[k] = \frac{R[k]}{\hat{H}[k]}</script><p>There is one defect of this approach. The equation above only holds if the channel performs a circular convolution on the signal.</p>
<script type="math/tex; mode=display">
s[n] \circledast h[n] = r[n] => \hat{S}[k] = \frac{R[k]}{\hat{H}[k]}</script><p>However the reality is the channel performs a linear convolution, because it is just a filter.</p>
<p><strong>If the signal is periodic, linear convolution and circular convolution are the same!</strong></p>
<p>Then let’s simply make our signal periodic!</p>
<p><strong>Take an OFDM symbol, take some time domain sample from the end, and then prepend them to the beginning.</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910153157123.png" alt="image-20230910153157123"></p>
<p>It is important that the cyclic prefix is at least as long as the channel inpulse response. The cyclic prefix will get impacted by the time smearing and the multipath channel. Since it’s duplicate information, it doesn’t really matter if it gets corrupted.</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910153523980.png" alt="image-20230910153523980"></p>
<p>So in the transmitter you have the IFFT output. then you add the cyclic prefix to get a full OFDM symbol, </p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910153655301.png" alt="image-20230910153655301"></p>
<p>On the other hand, in the receiver, the operation is run in reverse.</p>
<p><strong>First you strip off the cyclic prefix, getting rid of all that multipath corruption.</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910153932708.png" alt="image-20230910153932708"></p>
<p><strong>Then perform FFT,</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910154006082.png" alt="image-20230910154006082"></p>
<p>Then you can equalize the signal using that beautiful simple division!</p>
<script type="math/tex; mode=display">
\frac{R[k]}{\hat{H}[k]}</script><p>and your output is the QAM signal you start with.</p>
<p><strong>Note: In the OFDM, the guardbands are in the external part the whold bandwidth.</strong></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910154249442.png" alt="image-20230910154249442"></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910154332598.png" alt="image-20230910154332598"></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">bitsPerSymbol = <span class="built_in">log2</span>(modOrder);</span><br><span class="line">mpChan = [<span class="number">0.8</span>; <span class="built_in">zeros</span>(<span class="number">7</span>, <span class="number">1</span>); <span class="number">-0.5</span>; <span class="built_in">zeros</span>[<span class="number">7</span>, <span class="number">1</span>]; <span class="number">0.34</span>];<span class="comment">%multipath channel</span></span><br><span class="line">SNR = <span class="number">15</span>;</span><br><span class="line">numCarr = <span class="number">8192</span>;</span><br><span class="line">numBits = numCarr * bitsPerSymbol;</span><br><span class="line"><span class="comment">%the number of bits.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&quot;numBits&quot;</span>, <span class="string">&quot;var&quot;</span>)</span><br><span class="line">	srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line">	qamModOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">cycPrefLen = <span class="number">32</span>;</span><br><span class="line"><span class="comment">%the length of cyclic prefix is at least the same as that of inpulse response, which has the %length 17, 32&gt;17.</span></span><br><span class="line">ofdmModOut = ofdmmod(qamModOut, numCarr, cycPrefLen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&quot;ofdmModOut&quot;</span>, <span class="string">&quot;var&quot;</span>)</span><br><span class="line">	mpChanOut = filter(mpChan, <span class="number">1</span>, ofdmModOut);<span class="comment">%the multipath channel is equal to a filter.</span></span><br><span class="line">	chanOut = awgn(mpChanOut, SNR, <span class="string">&quot;measured&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ofdmDemodOut = ofdmdemod(chanOut, numCarr, cycPrefLen);<span class="comment">%demodulate and delete the prefix</span></span><br><span class="line">scatterplot(ofdmDemodOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">%Then use the division!</span></span><br><span class="line">npChanFreq = fftshift(fft(mpChan, numCarr));<span class="comment">%frequency response H</span></span><br><span class="line"><span class="comment">%fft 函数的输出以零频率分量开始，但 ofdmdemod 函数指定的是频率范围中间的零频率分量。使用 fftshift 移动信道的频谱，使零频率分量位于中心。</span></span><br><span class="line">eqOut = ofdmDemodOut ./ mpChanFreq;</span><br><span class="line">scatterplot(eqOut);</span><br><span class="line">title(<span class="string">&quot;Frequency Domain Equalizer Output&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&quot;eqOut&quot;</span>, <span class="string">&quot;var&quot;</span>)</span><br><span class="line">	qamDemodOut = qamdemod(eqOut, modOrder, <span class="string">&quot;OutputType&quot;</span>, <span class="string">&quot;bit&quot;</span>, <span class="string">&quot;UnitAveragePower&quot;</span>, <span class="built_in">true</span>);</span><br><span class="line">	numBitErrors = nnz(srcBits ~= qamDemodOut);</span><br><span class="line">	BER = numBitErrors ./ numBits;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>There are some additional attributions in the OFDM system, such as <strong>void subcarriers</strong>.</p>
<h3 id="Void-subcarriers"><a href="#Void-subcarriers" class="headerlink" title="Void subcarriers"></a>Void subcarriers</h3><p>People usually distribute guard bands to the lower part of bandwidth and the higher part of bandwidth, to reduce the interference from neighbors. They also give 0 to DC position, to remove the DC signals</p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910163842996.png" alt="image-20230910163842996"></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">modOrder = <span class="number">16</span>;</span><br><span class="line">bitsPerSymbol = <span class="built_in">log2</span>(modOrder);</span><br><span class="line">mpChan = [<span class="number">0.8</span>; <span class="built_in">zeros</span>(<span class="number">7</span>, <span class="number">1</span>); <span class="number">-0.5</span>; <span class="built_in">zeros</span>(<span class="number">7</span>, <span class="number">1</span>); <span class="number">0.34</span>];<span class="comment">%multipath channel</span></span><br><span class="line">SNR = <span class="number">15</span>;</span><br><span class="line">numCarr = <span class="number">8192</span>;</span><br><span class="line">cycPrefLen = <span class="number">32</span>;<span class="comment">%cyclic prefix length</span></span><br><span class="line"></span><br><span class="line">numGBCarr = numCarr / <span class="number">16</span>;</span><br><span class="line">gbLeft = <span class="number">1</span>:numGBCarr;<span class="comment">%safe guard band range, the left frequency part</span></span><br><span class="line">gbRight = (numCarr - numGBCarr + <span class="number">1</span>):numCarr;</span><br><span class="line"><span class="comment">%定义了左右两端的保护边带</span></span><br><span class="line"></span><br><span class="line">dcIdx = (numCarr / <span class="number">2</span>) + <span class="number">1</span>;<span class="comment">%the index of the dc band</span></span><br><span class="line">nullIdx = [gbLeft deIdx gbRight].&#x27;;</span><br><span class="line"><span class="comment">%this is the index of null bands</span></span><br><span class="line">numDataCarr = numCarr - <span class="built_in">length</span>(nullIdx);<span class="comment">%subtract null bands, remaining the data bands.</span></span><br><span class="line">numBits = numDataCarr * bitsPerSymbol;<span class="comment">%number of bits of data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%modulate</span></span><br><span class="line"><span class="keyword">if</span> exist(<span class="string">&quot;numBits&quot;</span>, <span class="string">&quot;var&quot;</span>)</span><br><span class="line">	srcBits = randi([<span class="number">0</span>, <span class="number">1</span>], numBits, <span class="number">1</span>);</span><br><span class="line">	qamModOut = qammod(srcBits, modOrder, <span class="string">&quot;InputType, &quot;</span>bit<span class="string">&quot;, &quot;</span>UnitAveragePower<span class="string">&quot;, true);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">ofdmModOut = ofdmmod(qamModOut, numCarr, cycPrefLen, nullIdx);%input null bands index %parameters</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">%channel part</span></span><br><span class="line"><span class="string">if exist(&quot;</span>ofdmModOut<span class="string">&quot;, &quot;</span>var<span class="string">&quot;)</span></span><br><span class="line"><span class="string">	mpChanOut = filter(mpChan, 1, ofdmModOut);</span></span><br><span class="line"><span class="string">	chanOut = awgn(mpChanOut, SNR, &quot;</span>measured<span class="string">&quot;);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ofdmDemodOut = ofdmdemod(chanOut, numCarr, cycPrefLen, cycPrefLen, nullIdx);</span></span><br><span class="line"><span class="string">%由于使用了空子载波，所以需要两个额外参数，采样偏移量和空索引向量。</span></span><br><span class="line"><span class="string">%采样偏移量就是执行fft之前丢弃的信号采样数。为0到循环前缀长度之间的任何值，也就是删除掉</span></span><br><span class="line"><span class="string">%被信道损坏的信息，所以我们直接用前缀长度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">%remove equalizer</span></span><br><span class="line"><span class="string">mpChanOut = fftshift(fft(mpChan, numCarr));%shift dc to the center</span></span><br><span class="line"><span class="string">%注意，包含了空子载波，因为要进行除法</span></span><br><span class="line"><span class="string">mpChanOut(nullIdx) = [];%空子载波被移除</span></span><br><span class="line"><span class="string">eqOut = ofdmDemodOut ./ mpChanOut;</span></span><br><span class="line"><span class="string">scatterplot(eqOut);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">%calculate BER</span></span><br><span class="line"><span class="string">if exist(&quot;</span>eqOut<span class="string">&quot;, &quot;</span>var<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    qamdemodOut = qamdemod(eqOut, modOrder, &quot;</span>OutputType<span class="string">&quot;, &quot;</span>bit<span class="string">&quot;, &quot;</span>UnitAveragePower<span class="string">&quot;, true);</span></span><br><span class="line"><span class="string">    numBitErrors = nnz(srcBits ~= qamdemodOut);</span></span><br><span class="line"><span class="string">    BER = numBitErrors / numBits;</span></span><br><span class="line"><span class="string">    disp(BER);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">%draw spectra analyser, draw the ofdm transmitting signal with yellow , and noise contained multipath signal with blue, including safe guard bands and dc band and frequency selecting fading.</span></span><br><span class="line"><span class="string">specAn = dsp.SpectrumAnalyzer(&quot;</span>NumInputPorts<span class="string">&quot;, 2, &quot;</span>SpectralAverages<span class="string">&quot;, 50, &quot;</span>ShowLegend<span class="string">&quot;, true, &quot;</span>ShowGrid<span class="string">&quot;, true);</span></span><br><span class="line"><span class="string">specAn(ofdmModOut, chanOut);</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910191254730.png" alt="image-20230910191254730"></p>
<p><img src="/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/image-20230910191310962.png" alt="image-20230910191310962"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://www.mathming.ltd">Spencer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.mathming.ltd/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/">http://www.mathming.ltd/2023/09/09/2023-9-9-Matlab-wireless-communication-foundation/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/wireless-communication/">wireless communication</a></div><div class="post_share"><div class="social-share" data-image="https://images.pexels.com/photos/1903702/pexels-photo-1903702.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/18/2023-9-18-FPGA%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" src="https://images.pexels.com/photos/1903702/pexels-photo-1903702.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">FPGA开发学习</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/30/2023-8-30-esp8266%E5%BC%80%E5%8F%91/"><img class="next-cover" src="https://images.pexels.com/photos/1903702/pexels-photo-1903702.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">esp8266开发</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Matlab-wireless-communication-foundation"><span class="toc-number">1.</span> <span class="toc-text">Matlab wireless communication foundation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QAM-modulation"><span class="toc-number">1.1.</span> <span class="toc-text">QAM modulation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QAM-modulation-and-AWGN-Additive-White-Gauss-Noise-channel"><span class="toc-number">1.2.</span> <span class="toc-text">QAM modulation and AWGN(Additive White Gauss Noise)channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calculate-Bit-Error-Rate-BER"><span class="toc-number">1.3.</span> <span class="toc-text">Calculate Bit Error Rate(BER)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Matched-Filter"><span class="toc-number">1.4.</span> <span class="toc-text">Matched Filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mathpath-signal-recession"><span class="toc-number">1.5.</span> <span class="toc-text">Mathpath signal recession</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OFDM-Orthogonal-Frequency-Division-Multiplexing"><span class="toc-number">1.6.</span> <span class="toc-text">OFDM(Orthogonal Frequency Division Multiplexing)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Void-subcarriers"><span class="toc-number">1.6.1.</span> <span class="toc-text">Void subcarriers</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://images.pexels.com/photos/1903702/pexels-photo-1903702.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=1')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Spencer</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'mSxoclNsLL8NLtvo34kDJbBy-MdYXbMMI',
      appKey: 'tLnjWwSLTZNRpGzOL7BMgXfN',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><a href="https://beian.miit.gov.cn/" target="_blank" class="is-center">冀ICP备2021024675号-1</a><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>